// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datarobot

import (
	"context"
	"reflect"

	"errors"
	"github.com/datarobot-community/pulumi-datarobot/sdk/go/datarobot/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Data store
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/datarobot-community/pulumi-datarobot/sdk/go/datarobot"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleConnector, err := datarobot.NewDatastore(ctx, "exampleConnector", &datarobot.DatastoreArgs{
//				CanonicalName: pulumi.String("Example Connector Datastore"),
//				DataStoreType: pulumi.String("dr-connector-v1"),
//				ConnectorId:   pulumi.String("65538041dde6a1d664d0b2ec"),
//				Fields: pulumi.StringMapArray{
//					pulumi.StringMap{
//						"id":    pulumi.String("fs.defaultFS"),
//						"name":  pulumi.String("Bucket Name"),
//						"value": pulumi.String("my-bucket"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datarobot.NewDatastore(ctx, "exampleJdbc", &datarobot.DatastoreArgs{
//				CanonicalName: pulumi.String("Example JDBC Datastore"),
//				DataStoreType: pulumi.String("jdbc"),
//				DriverId:      pulumi.String("5b4752844bf542000175dbea"),
//				Fields: pulumi.StringMapArray{
//					pulumi.StringMap{
//						"name":  pulumi.String("address"),
//						"value": pulumi.String("my-address"),
//					},
//					pulumi.StringMap{
//						"name":  pulumi.String("database"),
//						"value": pulumi.String("my-database"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datarobot.NewDatastore(ctx, "exampleDatabase", &datarobot.DatastoreArgs{
//				CanonicalName: pulumi.String("Example Database Datastore"),
//				DataStoreType: pulumi.String("dr-database-v1"),
//				DriverId:      pulumi.String("64a288a50636598d75df7f82"),
//				Fields: pulumi.StringMapArray{
//					pulumi.StringMap{
//						"id":    pulumi.String("bq.project_id"),
//						"name":  pulumi.String("Project Id"),
//						"value": pulumi.String("project-id"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("exampleConnectorId", exampleConnector.ID())
//			return nil
//		})
//	}
//
// ```
type Datastore struct {
	pulumi.CustomResourceState

	// The user-friendly name of the data store.
	CanonicalName pulumi.StringOutput `pulumi:"canonicalName"`
	// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
	ConnectorId pulumi.StringPtrOutput `pulumi:"connectorId"`
	// The type of data store.
	DataStoreType pulumi.StringOutput `pulumi:"dataStoreType"`
	// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
	DriverId pulumi.StringPtrOutput `pulumi:"driverId"`
	// If the type is dr-database-v1, then the fields specify the configuration.
	Fields pulumi.StringMapArrayOutput `pulumi:"fields"`
	// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
	JdbcUrl pulumi.StringPtrOutput `pulumi:"jdbcUrl"`
}

// NewDatastore registers a new resource with the given unique name, arguments, and options.
func NewDatastore(ctx *pulumi.Context,
	name string, args *DatastoreArgs, opts ...pulumi.ResourceOption) (*Datastore, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CanonicalName == nil {
		return nil, errors.New("invalid value for required argument 'CanonicalName'")
	}
	if args.DataStoreType == nil {
		return nil, errors.New("invalid value for required argument 'DataStoreType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Datastore
	err := ctx.RegisterResource("datarobot:index/datastore:Datastore", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDatastore gets an existing Datastore resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDatastore(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DatastoreState, opts ...pulumi.ResourceOption) (*Datastore, error) {
	var resource Datastore
	err := ctx.ReadResource("datarobot:index/datastore:Datastore", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Datastore resources.
type datastoreState struct {
	// The user-friendly name of the data store.
	CanonicalName *string `pulumi:"canonicalName"`
	// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
	ConnectorId *string `pulumi:"connectorId"`
	// The type of data store.
	DataStoreType *string `pulumi:"dataStoreType"`
	// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
	DriverId *string `pulumi:"driverId"`
	// If the type is dr-database-v1, then the fields specify the configuration.
	Fields []map[string]string `pulumi:"fields"`
	// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
	JdbcUrl *string `pulumi:"jdbcUrl"`
}

type DatastoreState struct {
	// The user-friendly name of the data store.
	CanonicalName pulumi.StringPtrInput
	// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
	ConnectorId pulumi.StringPtrInput
	// The type of data store.
	DataStoreType pulumi.StringPtrInput
	// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
	DriverId pulumi.StringPtrInput
	// If the type is dr-database-v1, then the fields specify the configuration.
	Fields pulumi.StringMapArrayInput
	// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
	JdbcUrl pulumi.StringPtrInput
}

func (DatastoreState) ElementType() reflect.Type {
	return reflect.TypeOf((*datastoreState)(nil)).Elem()
}

type datastoreArgs struct {
	// The user-friendly name of the data store.
	CanonicalName string `pulumi:"canonicalName"`
	// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
	ConnectorId *string `pulumi:"connectorId"`
	// The type of data store.
	DataStoreType string `pulumi:"dataStoreType"`
	// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
	DriverId *string `pulumi:"driverId"`
	// If the type is dr-database-v1, then the fields specify the configuration.
	Fields []map[string]string `pulumi:"fields"`
	// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
	JdbcUrl *string `pulumi:"jdbcUrl"`
}

// The set of arguments for constructing a Datastore resource.
type DatastoreArgs struct {
	// The user-friendly name of the data store.
	CanonicalName pulumi.StringInput
	// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
	ConnectorId pulumi.StringPtrInput
	// The type of data store.
	DataStoreType pulumi.StringInput
	// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
	DriverId pulumi.StringPtrInput
	// If the type is dr-database-v1, then the fields specify the configuration.
	Fields pulumi.StringMapArrayInput
	// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
	JdbcUrl pulumi.StringPtrInput
}

func (DatastoreArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*datastoreArgs)(nil)).Elem()
}

type DatastoreInput interface {
	pulumi.Input

	ToDatastoreOutput() DatastoreOutput
	ToDatastoreOutputWithContext(ctx context.Context) DatastoreOutput
}

func (*Datastore) ElementType() reflect.Type {
	return reflect.TypeOf((**Datastore)(nil)).Elem()
}

func (i *Datastore) ToDatastoreOutput() DatastoreOutput {
	return i.ToDatastoreOutputWithContext(context.Background())
}

func (i *Datastore) ToDatastoreOutputWithContext(ctx context.Context) DatastoreOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreOutput)
}

// DatastoreArrayInput is an input type that accepts DatastoreArray and DatastoreArrayOutput values.
// You can construct a concrete instance of `DatastoreArrayInput` via:
//
//	DatastoreArray{ DatastoreArgs{...} }
type DatastoreArrayInput interface {
	pulumi.Input

	ToDatastoreArrayOutput() DatastoreArrayOutput
	ToDatastoreArrayOutputWithContext(context.Context) DatastoreArrayOutput
}

type DatastoreArray []DatastoreInput

func (DatastoreArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Datastore)(nil)).Elem()
}

func (i DatastoreArray) ToDatastoreArrayOutput() DatastoreArrayOutput {
	return i.ToDatastoreArrayOutputWithContext(context.Background())
}

func (i DatastoreArray) ToDatastoreArrayOutputWithContext(ctx context.Context) DatastoreArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreArrayOutput)
}

// DatastoreMapInput is an input type that accepts DatastoreMap and DatastoreMapOutput values.
// You can construct a concrete instance of `DatastoreMapInput` via:
//
//	DatastoreMap{ "key": DatastoreArgs{...} }
type DatastoreMapInput interface {
	pulumi.Input

	ToDatastoreMapOutput() DatastoreMapOutput
	ToDatastoreMapOutputWithContext(context.Context) DatastoreMapOutput
}

type DatastoreMap map[string]DatastoreInput

func (DatastoreMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Datastore)(nil)).Elem()
}

func (i DatastoreMap) ToDatastoreMapOutput() DatastoreMapOutput {
	return i.ToDatastoreMapOutputWithContext(context.Background())
}

func (i DatastoreMap) ToDatastoreMapOutputWithContext(ctx context.Context) DatastoreMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreMapOutput)
}

type DatastoreOutput struct{ *pulumi.OutputState }

func (DatastoreOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Datastore)(nil)).Elem()
}

func (o DatastoreOutput) ToDatastoreOutput() DatastoreOutput {
	return o
}

func (o DatastoreOutput) ToDatastoreOutputWithContext(ctx context.Context) DatastoreOutput {
	return o
}

// The user-friendly name of the data store.
func (o DatastoreOutput) CanonicalName() pulumi.StringOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringOutput { return v.CanonicalName }).(pulumi.StringOutput)
}

// The identifier of the Connector if data*store*type is DR*CONNECTOR*V1
func (o DatastoreOutput) ConnectorId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringPtrOutput { return v.ConnectorId }).(pulumi.StringPtrOutput)
}

// The type of data store.
func (o DatastoreOutput) DataStoreType() pulumi.StringOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringOutput { return v.DataStoreType }).(pulumi.StringOutput)
}

// The identifier of the DataDriver if data*store*type is JDBC or DR*DATABASE*V1
func (o DatastoreOutput) DriverId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringPtrOutput { return v.DriverId }).(pulumi.StringPtrOutput)
}

// If the type is dr-database-v1, then the fields specify the configuration.
func (o DatastoreOutput) Fields() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringMapArrayOutput { return v.Fields }).(pulumi.StringMapArrayOutput)
}

// The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).
func (o DatastoreOutput) JdbcUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Datastore) pulumi.StringPtrOutput { return v.JdbcUrl }).(pulumi.StringPtrOutput)
}

type DatastoreArrayOutput struct{ *pulumi.OutputState }

func (DatastoreArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Datastore)(nil)).Elem()
}

func (o DatastoreArrayOutput) ToDatastoreArrayOutput() DatastoreArrayOutput {
	return o
}

func (o DatastoreArrayOutput) ToDatastoreArrayOutputWithContext(ctx context.Context) DatastoreArrayOutput {
	return o
}

func (o DatastoreArrayOutput) Index(i pulumi.IntInput) DatastoreOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Datastore {
		return vs[0].([]*Datastore)[vs[1].(int)]
	}).(DatastoreOutput)
}

type DatastoreMapOutput struct{ *pulumi.OutputState }

func (DatastoreMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Datastore)(nil)).Elem()
}

func (o DatastoreMapOutput) ToDatastoreMapOutput() DatastoreMapOutput {
	return o
}

func (o DatastoreMapOutput) ToDatastoreMapOutputWithContext(ctx context.Context) DatastoreMapOutput {
	return o
}

func (o DatastoreMapOutput) MapIndex(k pulumi.StringInput) DatastoreOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Datastore {
		return vs[0].(map[string]*Datastore)[vs[1].(string)]
	}).(DatastoreOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreInput)(nil)).Elem(), &Datastore{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreArrayInput)(nil)).Elem(), DatastoreArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreMapInput)(nil)).Elem(), DatastoreMap{})
	pulumi.RegisterOutputType(DatastoreOutput{})
	pulumi.RegisterOutputType(DatastoreArrayOutput{})
	pulumi.RegisterOutputType(DatastoreMapOutput{})
}
