// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datarobot

import (
	"context"
	"reflect"

	"errors"
	"github.com/datarobot-community/pulumi-datarobot/sdk/go/datarobot/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Data Set from Data Source.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/datarobot-community/pulumi-datarobot/sdk/go/datarobot"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := datarobot.NewDatasetFromDatasource(ctx, "example", &datarobot.DatasetFromDatasourceArgs{
//				DatasourceId:              pulumi.Any(datarobot_datasource.Example.Id),
//				CredentialId:              pulumi.Any(datarobot_credential.Example.Id),
//				DoSnapshot:                pulumi.Bool(false),
//				PersistDataAfterIngestion: pulumi.Bool(false),
//				UseKerberos:               pulumi.Bool(true),
//				Categories: pulumi.StringArray{
//					pulumi.String("TRAINING"),
//				},
//				UseCaseIds: pulumi.StringArray{
//					datarobot_use_case.Example.Id,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("exampleId", example.ID())
//			return nil
//		})
//	}
//
// ```
type DatasetFromDatasource struct {
	pulumi.CustomResourceState

	// An array of strings describing the intended use of the dataset.
	Categories pulumi.StringArrayOutput `pulumi:"categories"`
	// The ID of the set of credentials to use.
	CredentialId pulumi.StringOutput `pulumi:"credentialId"`
	// The ID for the DataSource to use as the source of data.
	DataSourceId pulumi.StringOutput `pulumi:"dataSourceId"`
	// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
	DoSnapshot pulumi.BoolOutput `pulumi:"doSnapshot"`
	// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
	PersistDataAfterIngestion pulumi.BoolOutput `pulumi:"persistDataAfterIngestion"`
	// The number of rows fetched during dataset registration.
	SampleSizeRows pulumi.IntPtrOutput `pulumi:"sampleSizeRows"`
	// The list of Use Case IDs to add the Dataset to.
	UseCaseIds pulumi.StringArrayOutput `pulumi:"useCaseIds"`
	// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
	UseKerberos pulumi.BoolOutput `pulumi:"useKerberos"`
}

// NewDatasetFromDatasource registers a new resource with the given unique name, arguments, and options.
func NewDatasetFromDatasource(ctx *pulumi.Context,
	name string, args *DatasetFromDatasourceArgs, opts ...pulumi.ResourceOption) (*DatasetFromDatasource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CredentialId == nil {
		return nil, errors.New("invalid value for required argument 'CredentialId'")
	}
	if args.DataSourceId == nil {
		return nil, errors.New("invalid value for required argument 'DataSourceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DatasetFromDatasource
	err := ctx.RegisterResource("datarobot:index/datasetFromDatasource:DatasetFromDatasource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDatasetFromDatasource gets an existing DatasetFromDatasource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDatasetFromDatasource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DatasetFromDatasourceState, opts ...pulumi.ResourceOption) (*DatasetFromDatasource, error) {
	var resource DatasetFromDatasource
	err := ctx.ReadResource("datarobot:index/datasetFromDatasource:DatasetFromDatasource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DatasetFromDatasource resources.
type datasetFromDatasourceState struct {
	// An array of strings describing the intended use of the dataset.
	Categories []string `pulumi:"categories"`
	// The ID of the set of credentials to use.
	CredentialId *string `pulumi:"credentialId"`
	// The ID for the DataSource to use as the source of data.
	DataSourceId *string `pulumi:"dataSourceId"`
	// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
	DoSnapshot *bool `pulumi:"doSnapshot"`
	// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
	PersistDataAfterIngestion *bool `pulumi:"persistDataAfterIngestion"`
	// The number of rows fetched during dataset registration.
	SampleSizeRows *int `pulumi:"sampleSizeRows"`
	// The list of Use Case IDs to add the Dataset to.
	UseCaseIds []string `pulumi:"useCaseIds"`
	// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
	UseKerberos *bool `pulumi:"useKerberos"`
}

type DatasetFromDatasourceState struct {
	// An array of strings describing the intended use of the dataset.
	Categories pulumi.StringArrayInput
	// The ID of the set of credentials to use.
	CredentialId pulumi.StringPtrInput
	// The ID for the DataSource to use as the source of data.
	DataSourceId pulumi.StringPtrInput
	// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
	DoSnapshot pulumi.BoolPtrInput
	// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
	PersistDataAfterIngestion pulumi.BoolPtrInput
	// The number of rows fetched during dataset registration.
	SampleSizeRows pulumi.IntPtrInput
	// The list of Use Case IDs to add the Dataset to.
	UseCaseIds pulumi.StringArrayInput
	// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
	UseKerberos pulumi.BoolPtrInput
}

func (DatasetFromDatasourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*datasetFromDatasourceState)(nil)).Elem()
}

type datasetFromDatasourceArgs struct {
	// An array of strings describing the intended use of the dataset.
	Categories []string `pulumi:"categories"`
	// The ID of the set of credentials to use.
	CredentialId string `pulumi:"credentialId"`
	// The ID for the DataSource to use as the source of data.
	DataSourceId string `pulumi:"dataSourceId"`
	// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
	DoSnapshot *bool `pulumi:"doSnapshot"`
	// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
	PersistDataAfterIngestion *bool `pulumi:"persistDataAfterIngestion"`
	// The number of rows fetched during dataset registration.
	SampleSizeRows *int `pulumi:"sampleSizeRows"`
	// The list of Use Case IDs to add the Dataset to.
	UseCaseIds []string `pulumi:"useCaseIds"`
	// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
	UseKerberos *bool `pulumi:"useKerberos"`
}

// The set of arguments for constructing a DatasetFromDatasource resource.
type DatasetFromDatasourceArgs struct {
	// An array of strings describing the intended use of the dataset.
	Categories pulumi.StringArrayInput
	// The ID of the set of credentials to use.
	CredentialId pulumi.StringInput
	// The ID for the DataSource to use as the source of data.
	DataSourceId pulumi.StringInput
	// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
	DoSnapshot pulumi.BoolPtrInput
	// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
	PersistDataAfterIngestion pulumi.BoolPtrInput
	// The number of rows fetched during dataset registration.
	SampleSizeRows pulumi.IntPtrInput
	// The list of Use Case IDs to add the Dataset to.
	UseCaseIds pulumi.StringArrayInput
	// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
	UseKerberos pulumi.BoolPtrInput
}

func (DatasetFromDatasourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*datasetFromDatasourceArgs)(nil)).Elem()
}

type DatasetFromDatasourceInput interface {
	pulumi.Input

	ToDatasetFromDatasourceOutput() DatasetFromDatasourceOutput
	ToDatasetFromDatasourceOutputWithContext(ctx context.Context) DatasetFromDatasourceOutput
}

func (*DatasetFromDatasource) ElementType() reflect.Type {
	return reflect.TypeOf((**DatasetFromDatasource)(nil)).Elem()
}

func (i *DatasetFromDatasource) ToDatasetFromDatasourceOutput() DatasetFromDatasourceOutput {
	return i.ToDatasetFromDatasourceOutputWithContext(context.Background())
}

func (i *DatasetFromDatasource) ToDatasetFromDatasourceOutputWithContext(ctx context.Context) DatasetFromDatasourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatasetFromDatasourceOutput)
}

// DatasetFromDatasourceArrayInput is an input type that accepts DatasetFromDatasourceArray and DatasetFromDatasourceArrayOutput values.
// You can construct a concrete instance of `DatasetFromDatasourceArrayInput` via:
//
//	DatasetFromDatasourceArray{ DatasetFromDatasourceArgs{...} }
type DatasetFromDatasourceArrayInput interface {
	pulumi.Input

	ToDatasetFromDatasourceArrayOutput() DatasetFromDatasourceArrayOutput
	ToDatasetFromDatasourceArrayOutputWithContext(context.Context) DatasetFromDatasourceArrayOutput
}

type DatasetFromDatasourceArray []DatasetFromDatasourceInput

func (DatasetFromDatasourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatasetFromDatasource)(nil)).Elem()
}

func (i DatasetFromDatasourceArray) ToDatasetFromDatasourceArrayOutput() DatasetFromDatasourceArrayOutput {
	return i.ToDatasetFromDatasourceArrayOutputWithContext(context.Background())
}

func (i DatasetFromDatasourceArray) ToDatasetFromDatasourceArrayOutputWithContext(ctx context.Context) DatasetFromDatasourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatasetFromDatasourceArrayOutput)
}

// DatasetFromDatasourceMapInput is an input type that accepts DatasetFromDatasourceMap and DatasetFromDatasourceMapOutput values.
// You can construct a concrete instance of `DatasetFromDatasourceMapInput` via:
//
//	DatasetFromDatasourceMap{ "key": DatasetFromDatasourceArgs{...} }
type DatasetFromDatasourceMapInput interface {
	pulumi.Input

	ToDatasetFromDatasourceMapOutput() DatasetFromDatasourceMapOutput
	ToDatasetFromDatasourceMapOutputWithContext(context.Context) DatasetFromDatasourceMapOutput
}

type DatasetFromDatasourceMap map[string]DatasetFromDatasourceInput

func (DatasetFromDatasourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatasetFromDatasource)(nil)).Elem()
}

func (i DatasetFromDatasourceMap) ToDatasetFromDatasourceMapOutput() DatasetFromDatasourceMapOutput {
	return i.ToDatasetFromDatasourceMapOutputWithContext(context.Background())
}

func (i DatasetFromDatasourceMap) ToDatasetFromDatasourceMapOutputWithContext(ctx context.Context) DatasetFromDatasourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatasetFromDatasourceMapOutput)
}

type DatasetFromDatasourceOutput struct{ *pulumi.OutputState }

func (DatasetFromDatasourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DatasetFromDatasource)(nil)).Elem()
}

func (o DatasetFromDatasourceOutput) ToDatasetFromDatasourceOutput() DatasetFromDatasourceOutput {
	return o
}

func (o DatasetFromDatasourceOutput) ToDatasetFromDatasourceOutputWithContext(ctx context.Context) DatasetFromDatasourceOutput {
	return o
}

// An array of strings describing the intended use of the dataset.
func (o DatasetFromDatasourceOutput) Categories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.StringArrayOutput { return v.Categories }).(pulumi.StringArrayOutput)
}

// The ID of the set of credentials to use.
func (o DatasetFromDatasourceOutput) CredentialId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.StringOutput { return v.CredentialId }).(pulumi.StringOutput)
}

// The ID for the DataSource to use as the source of data.
func (o DatasetFromDatasourceOutput) DataSourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.StringOutput { return v.DataSourceId }).(pulumi.StringOutput)
}

// If unset, uses the server default: True. If true, creates a snapshot dataset; if false, creates a remote dataset.
func (o DatasetFromDatasourceOutput) DoSnapshot() pulumi.BoolOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.BoolOutput { return v.DoSnapshot }).(pulumi.BoolOutput)
}

// If unset, uses the server default: True. If true, will enforce saving all data (for download and sampling) and will allow a user to view extended data profile (which includes data statistics like min/max/median/mean, histogram, etc.). If false, will not enforce saving data. The data schema (feature names and types) still will be available.
func (o DatasetFromDatasourceOutput) PersistDataAfterIngestion() pulumi.BoolOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.BoolOutput { return v.PersistDataAfterIngestion }).(pulumi.BoolOutput)
}

// The number of rows fetched during dataset registration.
func (o DatasetFromDatasourceOutput) SampleSizeRows() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.IntPtrOutput { return v.SampleSizeRows }).(pulumi.IntPtrOutput)
}

// The list of Use Case IDs to add the Dataset to.
func (o DatasetFromDatasourceOutput) UseCaseIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.StringArrayOutput { return v.UseCaseIds }).(pulumi.StringArrayOutput)
}

// If unset, uses the server default: False. If true, use kerberos authentication for database authentication.
func (o DatasetFromDatasourceOutput) UseKerberos() pulumi.BoolOutput {
	return o.ApplyT(func(v *DatasetFromDatasource) pulumi.BoolOutput { return v.UseKerberos }).(pulumi.BoolOutput)
}

type DatasetFromDatasourceArrayOutput struct{ *pulumi.OutputState }

func (DatasetFromDatasourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatasetFromDatasource)(nil)).Elem()
}

func (o DatasetFromDatasourceArrayOutput) ToDatasetFromDatasourceArrayOutput() DatasetFromDatasourceArrayOutput {
	return o
}

func (o DatasetFromDatasourceArrayOutput) ToDatasetFromDatasourceArrayOutputWithContext(ctx context.Context) DatasetFromDatasourceArrayOutput {
	return o
}

func (o DatasetFromDatasourceArrayOutput) Index(i pulumi.IntInput) DatasetFromDatasourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DatasetFromDatasource {
		return vs[0].([]*DatasetFromDatasource)[vs[1].(int)]
	}).(DatasetFromDatasourceOutput)
}

type DatasetFromDatasourceMapOutput struct{ *pulumi.OutputState }

func (DatasetFromDatasourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatasetFromDatasource)(nil)).Elem()
}

func (o DatasetFromDatasourceMapOutput) ToDatasetFromDatasourceMapOutput() DatasetFromDatasourceMapOutput {
	return o
}

func (o DatasetFromDatasourceMapOutput) ToDatasetFromDatasourceMapOutputWithContext(ctx context.Context) DatasetFromDatasourceMapOutput {
	return o
}

func (o DatasetFromDatasourceMapOutput) MapIndex(k pulumi.StringInput) DatasetFromDatasourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DatasetFromDatasource {
		return vs[0].(map[string]*DatasetFromDatasource)[vs[1].(string)]
	}).(DatasetFromDatasourceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DatasetFromDatasourceInput)(nil)).Elem(), &DatasetFromDatasource{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatasetFromDatasourceArrayInput)(nil)).Elem(), DatasetFromDatasourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatasetFromDatasourceMapInput)(nil)).Elem(), DatasetFromDatasourceMap{})
	pulumi.RegisterOutputType(DatasetFromDatasourceOutput{})
	pulumi.RegisterOutputType(DatasetFromDatasourceArrayOutput{})
	pulumi.RegisterOutputType(DatasetFromDatasourceMapOutput{})
}
