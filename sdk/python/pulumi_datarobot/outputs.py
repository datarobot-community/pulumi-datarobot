# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApplicationSourceRuntimeParameterValue',
    'CustomModelGuardConfiguration',
    'CustomModelGuardConfigurationIntervention',
    'CustomModelGuardConfigurationNemoInfo',
    'CustomModelOverallModerationConfiguration',
    'CustomModelRuntimeParameterValue',
    'CustomModelSourceRemoteRepository',
    'DatasourceParams',
    'DeploymentAssociationIdSettings',
    'DeploymentBiasAndFairnessSettings',
    'DeploymentChallengerModelsSettings',
    'DeploymentChallengerReplaySettings',
    'DeploymentDriftTrackingSettings',
    'DeploymentHealthSettings',
    'DeploymentHealthSettingsAccuracy',
    'DeploymentHealthSettingsActualsTimeliness',
    'DeploymentHealthSettingsCustomMetrics',
    'DeploymentHealthSettingsCustomMetricsFailingCondition',
    'DeploymentHealthSettingsCustomMetricsWarningCondition',
    'DeploymentHealthSettingsDataDrift',
    'DeploymentHealthSettingsFairness',
    'DeploymentHealthSettingsPredictionsTimeliness',
    'DeploymentHealthSettingsService',
    'DeploymentPredictionIntervalsSettings',
    'DeploymentPredictionWarningSettings',
    'DeploymentPredictionWarningSettingsCustomBoundaries',
    'DeploymentPredictionsByForecastDateSettings',
    'DeploymentPredictionsDataCollectionSettings',
    'DeploymentPredictionsSettings',
    'DeploymentSegmentAnalysisSettings',
    'LlmBlueprintLlmSettings',
    'LlmBlueprintVectorDatabaseSettings',
    'VectorDatabaseChunkingParameters',
]

@pulumi.output_type
class ApplicationSourceRuntimeParameterValue(dict):
    def __init__(__self__, *,
                 key: str,
                 type: str,
                 value: str):
        """
        :param str key: The name of the runtime parameter.
        :param str type: The type of the runtime parameter.
        :param str value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomModelGuardConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "deploymentId":
            suggest = "deployment_id"
        elif key == "inputColumnName":
            suggest = "input_column_name"
        elif key == "llmType":
            suggest = "llm_type"
        elif key == "nemoInfo":
            suggest = "nemo_info"
        elif key == "openaiApiBase":
            suggest = "openai_api_base"
        elif key == "openaiCredential":
            suggest = "openai_credential"
        elif key == "openaiDeploymentId":
            suggest = "openai_deployment_id"
        elif key == "outputColumnName":
            suggest = "output_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelGuardConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelGuardConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelGuardConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intervention: 'outputs.CustomModelGuardConfigurationIntervention',
                 name: str,
                 stages: Sequence[str],
                 template_name: str,
                 deployment_id: Optional[str] = None,
                 input_column_name: Optional[str] = None,
                 llm_type: Optional[str] = None,
                 nemo_info: Optional['outputs.CustomModelGuardConfigurationNemoInfo'] = None,
                 openai_api_base: Optional[str] = None,
                 openai_credential: Optional[str] = None,
                 openai_deployment_id: Optional[str] = None,
                 output_column_name: Optional[str] = None):
        """
        :param 'CustomModelGuardConfigurationInterventionArgs' intervention: The intervention for the guard configuration.
        :param str name: The name of the guard configuration.
        :param Sequence[str] stages: The list of stages for the guard configuration.
        :param str template_name: The template name of the guard configuration.
        :param str deployment_id: The deployment ID of this guard.
        :param str input_column_name: The input column name of this guard.
        :param str llm_type: The LLM type for this guard.
        :param 'CustomModelGuardConfigurationNemoInfoArgs' nemo_info: Configuration info for NeMo guards.
        :param str openai_api_base: The OpenAI API base URL for this guard.
        :param str openai_credential: The ID of an OpenAI credential for this guard.
        :param str openai_deployment_id: The ID of an OpenAI deployment for this guard.
        :param str output_column_name: The output column name of this guard.
        """
        pulumi.set(__self__, "intervention", intervention)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "template_name", template_name)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if input_column_name is not None:
            pulumi.set(__self__, "input_column_name", input_column_name)
        if llm_type is not None:
            pulumi.set(__self__, "llm_type", llm_type)
        if nemo_info is not None:
            pulumi.set(__self__, "nemo_info", nemo_info)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_credential is not None:
            pulumi.set(__self__, "openai_credential", openai_credential)
        if openai_deployment_id is not None:
            pulumi.set(__self__, "openai_deployment_id", openai_deployment_id)
        if output_column_name is not None:
            pulumi.set(__self__, "output_column_name", output_column_name)

    @property
    @pulumi.getter
    def intervention(self) -> 'outputs.CustomModelGuardConfigurationIntervention':
        """
        The intervention for the guard configuration.
        """
        return pulumi.get(self, "intervention")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the guard configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def stages(self) -> Sequence[str]:
        """
        The list of stages for the guard configuration.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> str:
        """
        The template name of the guard configuration.
        """
        return pulumi.get(self, "template_name")

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[str]:
        """
        The deployment ID of this guard.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter(name="inputColumnName")
    def input_column_name(self) -> Optional[str]:
        """
        The input column name of this guard.
        """
        return pulumi.get(self, "input_column_name")

    @property
    @pulumi.getter(name="llmType")
    def llm_type(self) -> Optional[str]:
        """
        The LLM type for this guard.
        """
        return pulumi.get(self, "llm_type")

    @property
    @pulumi.getter(name="nemoInfo")
    def nemo_info(self) -> Optional['outputs.CustomModelGuardConfigurationNemoInfo']:
        """
        Configuration info for NeMo guards.
        """
        return pulumi.get(self, "nemo_info")

    @property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[str]:
        """
        The OpenAI API base URL for this guard.
        """
        return pulumi.get(self, "openai_api_base")

    @property
    @pulumi.getter(name="openaiCredential")
    def openai_credential(self) -> Optional[str]:
        """
        The ID of an OpenAI credential for this guard.
        """
        return pulumi.get(self, "openai_credential")

    @property
    @pulumi.getter(name="openaiDeploymentId")
    def openai_deployment_id(self) -> Optional[str]:
        """
        The ID of an OpenAI deployment for this guard.
        """
        return pulumi.get(self, "openai_deployment_id")

    @property
    @pulumi.getter(name="outputColumnName")
    def output_column_name(self) -> Optional[str]:
        """
        The output column name of this guard.
        """
        return pulumi.get(self, "output_column_name")


@pulumi.output_type
class CustomModelGuardConfigurationIntervention(dict):
    def __init__(__self__, *,
                 action: str,
                 condition: str,
                 message: Optional[str] = None):
        """
        :param str action: The action of the guard intervention.
        :param str condition: The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        :param str message: The message of the guard intervention.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action of the guard intervention.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The message of the guard intervention.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class CustomModelGuardConfigurationNemoInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockedTerms":
            suggest = "blocked_terms"
        elif key == "llmPrompts":
            suggest = "llm_prompts"
        elif key == "mainConfig":
            suggest = "main_config"
        elif key == "railsConfig":
            suggest = "rails_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelGuardConfigurationNemoInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelGuardConfigurationNemoInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelGuardConfigurationNemoInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[str] = None,
                 blocked_terms: Optional[str] = None,
                 llm_prompts: Optional[str] = None,
                 main_config: Optional[str] = None,
                 rails_config: Optional[str] = None):
        """
        :param str actions: The actions for the NeMo information.
        :param str blocked_terms: NeMo guardrails blocked terms list.
        :param str llm_prompts: NeMo guardrails prompts.
        :param str main_config: Overall NeMo configuration YAML.
        :param str rails_config: NeMo guardrails configuration Colang.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if blocked_terms is not None:
            pulumi.set(__self__, "blocked_terms", blocked_terms)
        if llm_prompts is not None:
            pulumi.set(__self__, "llm_prompts", llm_prompts)
        if main_config is not None:
            pulumi.set(__self__, "main_config", main_config)
        if rails_config is not None:
            pulumi.set(__self__, "rails_config", rails_config)

    @property
    @pulumi.getter
    def actions(self) -> Optional[str]:
        """
        The actions for the NeMo information.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="blockedTerms")
    def blocked_terms(self) -> Optional[str]:
        """
        NeMo guardrails blocked terms list.
        """
        return pulumi.get(self, "blocked_terms")

    @property
    @pulumi.getter(name="llmPrompts")
    def llm_prompts(self) -> Optional[str]:
        """
        NeMo guardrails prompts.
        """
        return pulumi.get(self, "llm_prompts")

    @property
    @pulumi.getter(name="mainConfig")
    def main_config(self) -> Optional[str]:
        """
        Overall NeMo configuration YAML.
        """
        return pulumi.get(self, "main_config")

    @property
    @pulumi.getter(name="railsConfig")
    def rails_config(self) -> Optional[str]:
        """
        NeMo guardrails configuration Colang.
        """
        return pulumi.get(self, "rails_config")


@pulumi.output_type
class CustomModelOverallModerationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeoutAction":
            suggest = "timeout_action"
        elif key == "timeoutSec":
            suggest = "timeout_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelOverallModerationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelOverallModerationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelOverallModerationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timeout_action: Optional[str] = None,
                 timeout_sec: Optional[int] = None):
        """
        :param str timeout_action: The timeout action of the overall moderation configuration.
        :param int timeout_sec: The timeout in seconds of the overall moderation configuration.
        """
        if timeout_action is not None:
            pulumi.set(__self__, "timeout_action", timeout_action)
        if timeout_sec is not None:
            pulumi.set(__self__, "timeout_sec", timeout_sec)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> Optional[str]:
        """
        The timeout action of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_action")

    @property
    @pulumi.getter(name="timeoutSec")
    def timeout_sec(self) -> Optional[int]:
        """
        The timeout in seconds of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_sec")


@pulumi.output_type
class CustomModelRuntimeParameterValue(dict):
    def __init__(__self__, *,
                 key: str,
                 type: str,
                 value: str):
        """
        :param str key: The name of the runtime parameter.
        :param str type: The type of the runtime parameter.
        :param str value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomModelSourceRemoteRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePaths":
            suggest = "source_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelSourceRemoteRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelSourceRemoteRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelSourceRemoteRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 ref: str,
                 source_paths: Sequence[str]):
        """
        :param str id: The ID of the source remote repository.
        :param str ref: The reference of the source remote repository.
        :param Sequence[str] source_paths: The list of source paths in the source remote repository.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "source_paths", source_paths)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the source remote repository.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        The reference of the source remote repository.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter(name="sourcePaths")
    def source_paths(self) -> Sequence[str]:
        """
        The list of source paths in the source remote repository.
        """
        return pulumi.get(self, "source_paths")


@pulumi.output_type
class DatasourceParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreId":
            suggest = "data_store_id"
        elif key == "fetchSize":
            suggest = "fetch_size"
        elif key == "partitionColumn":
            suggest = "partition_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasourceParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasourceParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasourceParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store_id: str,
                 catalog: Optional[str] = None,
                 fetch_size: Optional[int] = None,
                 partition_column: Optional[str] = None,
                 path: Optional[str] = None,
                 query: Optional[str] = None,
                 schema: Optional[str] = None,
                 table: Optional[str] = None):
        """
        :param str data_store_id: The id of the DataStore.
        :param str catalog: The Catalog name in the database if supported.
        :param int fetch_size: A user specified fetch size in the range [1, 20000]. By default a fetchSize will be assigned to balance throughput and memory usage.
        :param str partition_column: The name of the partition column.
        :param str path: The user-specified path for BLOB storage.
        :param str query: The user specified SQL query.
        :param str schema: The name of the schema associated with the table.
        :param str table: The name of specified database table.
        """
        pulumi.set(__self__, "data_store_id", data_store_id)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if fetch_size is not None:
            pulumi.set(__self__, "fetch_size", fetch_size)
        if partition_column is not None:
            pulumi.set(__self__, "partition_column", partition_column)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="dataStoreId")
    def data_store_id(self) -> str:
        """
        The id of the DataStore.
        """
        return pulumi.get(self, "data_store_id")

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        """
        The Catalog name in the database if supported.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="fetchSize")
    def fetch_size(self) -> Optional[int]:
        """
        A user specified fetch size in the range [1, 20000]. By default a fetchSize will be assigned to balance throughput and memory usage.
        """
        return pulumi.get(self, "fetch_size")

    @property
    @pulumi.getter(name="partitionColumn")
    def partition_column(self) -> Optional[str]:
        """
        The name of the partition column.
        """
        return pulumi.get(self, "partition_column")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The user-specified path for BLOB storage.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The user specified SQL query.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The name of the schema associated with the table.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def table(self) -> Optional[str]:
        """
        The name of specified database table.
        """
        return pulumi.get(self, "table")


@pulumi.output_type
class DeploymentAssociationIdSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoGenerateId":
            suggest = "auto_generate_id"
        elif key == "columnNames":
            suggest = "column_names"
        elif key == "requiredInPredictionRequests":
            suggest = "required_in_prediction_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentAssociationIdSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentAssociationIdSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentAssociationIdSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_generate_id: Optional[bool] = None,
                 column_names: Optional[Sequence[str]] = None,
                 required_in_prediction_requests: Optional[bool] = None):
        """
        :param bool auto_generate_id: Whether to auto generate ID.
        :param Sequence[str] column_names: Name of the columns to be used as association ID, currently only support a list of one string.
        :param bool required_in_prediction_requests: Whether the association ID column is required in prediction requests.
        """
        if auto_generate_id is not None:
            pulumi.set(__self__, "auto_generate_id", auto_generate_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if required_in_prediction_requests is not None:
            pulumi.set(__self__, "required_in_prediction_requests", required_in_prediction_requests)

    @property
    @pulumi.getter(name="autoGenerateId")
    def auto_generate_id(self) -> Optional[bool]:
        """
        Whether to auto generate ID.
        """
        return pulumi.get(self, "auto_generate_id")

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        """
        Name of the columns to be used as association ID, currently only support a list of one string.
        """
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter(name="requiredInPredictionRequests")
    def required_in_prediction_requests(self) -> Optional[bool]:
        """
        Whether the association ID column is required in prediction requests.
        """
        return pulumi.get(self, "required_in_prediction_requests")


@pulumi.output_type
class DeploymentBiasAndFairnessSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fairnessMetricSet":
            suggest = "fairness_metric_set"
        elif key == "fairnessThreshold":
            suggest = "fairness_threshold"
        elif key == "preferableTargetValue":
            suggest = "preferable_target_value"
        elif key == "protectedFeatures":
            suggest = "protected_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentBiasAndFairnessSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentBiasAndFairnessSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentBiasAndFairnessSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fairness_metric_set: str,
                 fairness_threshold: float,
                 preferable_target_value: bool,
                 protected_features: Sequence[str]):
        """
        :param str fairness_metric_set: A set of fairness metrics to use for calculating fairness.
        :param float fairness_threshold: Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        :param bool preferable_target_value: A target value that should be treated as a positive outcome for the prediction.
        :param Sequence[str] protected_features: A list of features to mark as protected.
        """
        pulumi.set(__self__, "fairness_metric_set", fairness_metric_set)
        pulumi.set(__self__, "fairness_threshold", fairness_threshold)
        pulumi.set(__self__, "preferable_target_value", preferable_target_value)
        pulumi.set(__self__, "protected_features", protected_features)

    @property
    @pulumi.getter(name="fairnessMetricSet")
    def fairness_metric_set(self) -> str:
        """
        A set of fairness metrics to use for calculating fairness.
        """
        return pulumi.get(self, "fairness_metric_set")

    @property
    @pulumi.getter(name="fairnessThreshold")
    def fairness_threshold(self) -> float:
        """
        Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        """
        return pulumi.get(self, "fairness_threshold")

    @property
    @pulumi.getter(name="preferableTargetValue")
    def preferable_target_value(self) -> bool:
        """
        A target value that should be treated as a positive outcome for the prediction.
        """
        return pulumi.get(self, "preferable_target_value")

    @property
    @pulumi.getter(name="protectedFeatures")
    def protected_features(self) -> Sequence[str]:
        """
        A list of features to mark as protected.
        """
        return pulumi.get(self, "protected_features")


@pulumi.output_type
class DeploymentChallengerModelsSettings(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Is 'True' if challenger models is enabled for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is 'True' if challenger models is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeploymentChallengerReplaySettings(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: If challenger replay is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If challenger replay is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeploymentDriftTrackingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureDriftEnabled":
            suggest = "feature_drift_enabled"
        elif key == "targetDriftEnabled":
            suggest = "target_drift_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentDriftTrackingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentDriftTrackingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentDriftTrackingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_drift_enabled: Optional[bool] = None,
                 target_drift_enabled: Optional[bool] = None):
        """
        :param bool feature_drift_enabled: If feature drift tracking is to be turned on.
        :param bool target_drift_enabled: If target drift tracking is to be turned on.
        """
        if feature_drift_enabled is not None:
            pulumi.set(__self__, "feature_drift_enabled", feature_drift_enabled)
        if target_drift_enabled is not None:
            pulumi.set(__self__, "target_drift_enabled", target_drift_enabled)

    @property
    @pulumi.getter(name="featureDriftEnabled")
    def feature_drift_enabled(self) -> Optional[bool]:
        """
        If feature drift tracking is to be turned on.
        """
        return pulumi.get(self, "feature_drift_enabled")

    @property
    @pulumi.getter(name="targetDriftEnabled")
    def target_drift_enabled(self) -> Optional[bool]:
        """
        If target drift tracking is to be turned on.
        """
        return pulumi.get(self, "target_drift_enabled")


@pulumi.output_type
class DeploymentHealthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualsTimeliness":
            suggest = "actuals_timeliness"
        elif key == "customMetrics":
            suggest = "custom_metrics"
        elif key == "dataDrift":
            suggest = "data_drift"
        elif key == "predictionsTimeliness":
            suggest = "predictions_timeliness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accuracy: Optional['outputs.DeploymentHealthSettingsAccuracy'] = None,
                 actuals_timeliness: Optional['outputs.DeploymentHealthSettingsActualsTimeliness'] = None,
                 custom_metrics: Optional['outputs.DeploymentHealthSettingsCustomMetrics'] = None,
                 data_drift: Optional['outputs.DeploymentHealthSettingsDataDrift'] = None,
                 fairness: Optional['outputs.DeploymentHealthSettingsFairness'] = None,
                 predictions_timeliness: Optional['outputs.DeploymentHealthSettingsPredictionsTimeliness'] = None,
                 service: Optional['outputs.DeploymentHealthSettingsService'] = None):
        """
        :param 'DeploymentHealthSettingsAccuracyArgs' accuracy: The accuracy health settings for this Deployment.
        :param 'DeploymentHealthSettingsActualsTimelinessArgs' actuals_timeliness: The actuals timeliness health settings for this Deployment.
        :param 'DeploymentHealthSettingsCustomMetricsArgs' custom_metrics: The custom metrics health settings for this Deployment.
        :param 'DeploymentHealthSettingsDataDriftArgs' data_drift: The data drift health settings for this Deployment.
        :param 'DeploymentHealthSettingsFairnessArgs' fairness: The fairness health settings for this Deployment.
        :param 'DeploymentHealthSettingsPredictionsTimelinessArgs' predictions_timeliness: The predictions timeliness health settings for this Deployment.
        :param 'DeploymentHealthSettingsServiceArgs' service: The service health settings for this Deployment.
        """
        if accuracy is not None:
            pulumi.set(__self__, "accuracy", accuracy)
        if actuals_timeliness is not None:
            pulumi.set(__self__, "actuals_timeliness", actuals_timeliness)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if data_drift is not None:
            pulumi.set(__self__, "data_drift", data_drift)
        if fairness is not None:
            pulumi.set(__self__, "fairness", fairness)
        if predictions_timeliness is not None:
            pulumi.set(__self__, "predictions_timeliness", predictions_timeliness)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def accuracy(self) -> Optional['outputs.DeploymentHealthSettingsAccuracy']:
        """
        The accuracy health settings for this Deployment.
        """
        return pulumi.get(self, "accuracy")

    @property
    @pulumi.getter(name="actualsTimeliness")
    def actuals_timeliness(self) -> Optional['outputs.DeploymentHealthSettingsActualsTimeliness']:
        """
        The actuals timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "actuals_timeliness")

    @property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional['outputs.DeploymentHealthSettingsCustomMetrics']:
        """
        The custom metrics health settings for this Deployment.
        """
        return pulumi.get(self, "custom_metrics")

    @property
    @pulumi.getter(name="dataDrift")
    def data_drift(self) -> Optional['outputs.DeploymentHealthSettingsDataDrift']:
        """
        The data drift health settings for this Deployment.
        """
        return pulumi.get(self, "data_drift")

    @property
    @pulumi.getter
    def fairness(self) -> Optional['outputs.DeploymentHealthSettingsFairness']:
        """
        The fairness health settings for this Deployment.
        """
        return pulumi.get(self, "fairness")

    @property
    @pulumi.getter(name="predictionsTimeliness")
    def predictions_timeliness(self) -> Optional['outputs.DeploymentHealthSettingsPredictionsTimeliness']:
        """
        The predictions timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "predictions_timeliness")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.DeploymentHealthSettingsService']:
        """
        The service health settings for this Deployment.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class DeploymentHealthSettingsAccuracy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCount":
            suggest = "batch_count"
        elif key == "failingThreshold":
            suggest = "failing_threshold"
        elif key == "warningThreshold":
            suggest = "warning_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsAccuracy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsAccuracy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsAccuracy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_count: Optional[int] = None,
                 failing_threshold: Optional[float] = None,
                 measurement: Optional[str] = None,
                 metric: Optional[str] = None,
                 warning_threshold: Optional[float] = None):
        """
        :param int batch_count: The batch count for the accuracy health settings.
        :param float failing_threshold: The failing threshold for the accuracy health settings.
        :param str measurement: The measurement for the accuracy health settings.
        :param str metric: The metric for the accuracy health settings.
        :param float warning_threshold: The warning threshold for the accuracy health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if failing_threshold is not None:
            pulumi.set(__self__, "failing_threshold", failing_threshold)
        if measurement is not None:
            pulumi.set(__self__, "measurement", measurement)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if warning_threshold is not None:
            pulumi.set(__self__, "warning_threshold", warning_threshold)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[int]:
        """
        The batch count for the accuracy health settings.
        """
        return pulumi.get(self, "batch_count")

    @property
    @pulumi.getter(name="failingThreshold")
    def failing_threshold(self) -> Optional[float]:
        """
        The failing threshold for the accuracy health settings.
        """
        return pulumi.get(self, "failing_threshold")

    @property
    @pulumi.getter
    def measurement(self) -> Optional[str]:
        """
        The measurement for the accuracy health settings.
        """
        return pulumi.get(self, "measurement")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric for the accuracy health settings.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="warningThreshold")
    def warning_threshold(self) -> Optional[float]:
        """
        The warning threshold for the accuracy health settings.
        """
        return pulumi.get(self, "warning_threshold")


@pulumi.output_type
class DeploymentHealthSettingsActualsTimeliness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedFrequency":
            suggest = "expected_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsActualsTimeliness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsActualsTimeliness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsActualsTimeliness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 expected_frequency: Optional[str] = None):
        """
        :param bool enabled: If acutals timeliness is enabled for this Deployment.
        :param str expected_frequency: The expected frequency for the actuals timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If acutals timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[str]:
        """
        The expected frequency for the actuals timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")


@pulumi.output_type
class DeploymentHealthSettingsCustomMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failingConditions":
            suggest = "failing_conditions"
        elif key == "warningConditions":
            suggest = "warning_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsCustomMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsCustomMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsCustomMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failing_conditions: Optional[Sequence['outputs.DeploymentHealthSettingsCustomMetricsFailingCondition']] = None,
                 warning_conditions: Optional[Sequence['outputs.DeploymentHealthSettingsCustomMetricsWarningCondition']] = None):
        """
        :param Sequence['DeploymentHealthSettingsCustomMetricsFailingConditionArgs'] failing_conditions: The failing conditions for the custom metrics health settings.
        :param Sequence['DeploymentHealthSettingsCustomMetricsWarningConditionArgs'] warning_conditions: The warning conditions for the custom metrics health settings.
        """
        if failing_conditions is not None:
            pulumi.set(__self__, "failing_conditions", failing_conditions)
        if warning_conditions is not None:
            pulumi.set(__self__, "warning_conditions", warning_conditions)

    @property
    @pulumi.getter(name="failingConditions")
    def failing_conditions(self) -> Optional[Sequence['outputs.DeploymentHealthSettingsCustomMetricsFailingCondition']]:
        """
        The failing conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "failing_conditions")

    @property
    @pulumi.getter(name="warningConditions")
    def warning_conditions(self) -> Optional[Sequence['outputs.DeploymentHealthSettingsCustomMetricsWarningCondition']]:
        """
        The warning conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "warning_conditions")


@pulumi.output_type
class DeploymentHealthSettingsCustomMetricsFailingCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperator":
            suggest = "compare_operator"
        elif key == "metricId":
            suggest = "metric_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsCustomMetricsFailingCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsCustomMetricsFailingCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsCustomMetricsFailingCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operator: str,
                 metric_id: str,
                 threshold: float):
        """
        :param str compare_operator: The compare operator for the failing condition of the custom metrics health settings.
        :param str metric_id: The metric ID for the failing condition of the custom metrics health settings.
        :param float threshold: The threshold for the failing condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> str:
        """
        The compare operator for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        The metric ID for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DeploymentHealthSettingsCustomMetricsWarningCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperator":
            suggest = "compare_operator"
        elif key == "metricId":
            suggest = "metric_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsCustomMetricsWarningCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsCustomMetricsWarningCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsCustomMetricsWarningCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operator: str,
                 metric_id: str,
                 threshold: float):
        """
        :param str compare_operator: The compare operator for the warning condition of the custom metrics health settings.
        :param str metric_id: The metric ID for the warning condition of the custom metrics health settings.
        :param float threshold: The threshold for the warning condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> str:
        """
        The compare operator for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        The metric ID for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DeploymentHealthSettingsDataDrift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCount":
            suggest = "batch_count"
        elif key == "driftThreshold":
            suggest = "drift_threshold"
        elif key == "excludeFeatures":
            suggest = "exclude_features"
        elif key == "highImportanceFailingCount":
            suggest = "high_importance_failing_count"
        elif key == "highImportanceWarningCount":
            suggest = "high_importance_warning_count"
        elif key == "importanceThreshold":
            suggest = "importance_threshold"
        elif key == "lowImportanceFailingCount":
            suggest = "low_importance_failing_count"
        elif key == "lowImportanceWarningCount":
            suggest = "low_importance_warning_count"
        elif key == "starredFeatures":
            suggest = "starred_features"
        elif key == "timeInterval":
            suggest = "time_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsDataDrift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsDataDrift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsDataDrift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_count: Optional[int] = None,
                 drift_threshold: Optional[float] = None,
                 exclude_features: Optional[Sequence[str]] = None,
                 high_importance_failing_count: Optional[int] = None,
                 high_importance_warning_count: Optional[int] = None,
                 importance_threshold: Optional[float] = None,
                 low_importance_failing_count: Optional[int] = None,
                 low_importance_warning_count: Optional[int] = None,
                 starred_features: Optional[Sequence[str]] = None,
                 time_interval: Optional[str] = None):
        """
        :param int batch_count: The batch count for the data drift health settings.
        :param float drift_threshold: The drift threshold for the data drift health settings.
        :param Sequence[str] exclude_features: The exclude features for the data drift health settings.
        :param int high_importance_failing_count: The high importance failing count for the data drift health settings.
        :param int high_importance_warning_count: The high importance warning count for the data drift health settings.
        :param float importance_threshold: The importance threshold for the data drift health settings.
        :param int low_importance_failing_count: The low importance failing count for the data drift health settings.
        :param int low_importance_warning_count: The low importance warning count for the data drift health settings.
        :param Sequence[str] starred_features: The starred features for the data drift health settings.
        :param str time_interval: The time interval for the data drift health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if drift_threshold is not None:
            pulumi.set(__self__, "drift_threshold", drift_threshold)
        if exclude_features is not None:
            pulumi.set(__self__, "exclude_features", exclude_features)
        if high_importance_failing_count is not None:
            pulumi.set(__self__, "high_importance_failing_count", high_importance_failing_count)
        if high_importance_warning_count is not None:
            pulumi.set(__self__, "high_importance_warning_count", high_importance_warning_count)
        if importance_threshold is not None:
            pulumi.set(__self__, "importance_threshold", importance_threshold)
        if low_importance_failing_count is not None:
            pulumi.set(__self__, "low_importance_failing_count", low_importance_failing_count)
        if low_importance_warning_count is not None:
            pulumi.set(__self__, "low_importance_warning_count", low_importance_warning_count)
        if starred_features is not None:
            pulumi.set(__self__, "starred_features", starred_features)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[int]:
        """
        The batch count for the data drift health settings.
        """
        return pulumi.get(self, "batch_count")

    @property
    @pulumi.getter(name="driftThreshold")
    def drift_threshold(self) -> Optional[float]:
        """
        The drift threshold for the data drift health settings.
        """
        return pulumi.get(self, "drift_threshold")

    @property
    @pulumi.getter(name="excludeFeatures")
    def exclude_features(self) -> Optional[Sequence[str]]:
        """
        The exclude features for the data drift health settings.
        """
        return pulumi.get(self, "exclude_features")

    @property
    @pulumi.getter(name="highImportanceFailingCount")
    def high_importance_failing_count(self) -> Optional[int]:
        """
        The high importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_failing_count")

    @property
    @pulumi.getter(name="highImportanceWarningCount")
    def high_importance_warning_count(self) -> Optional[int]:
        """
        The high importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_warning_count")

    @property
    @pulumi.getter(name="importanceThreshold")
    def importance_threshold(self) -> Optional[float]:
        """
        The importance threshold for the data drift health settings.
        """
        return pulumi.get(self, "importance_threshold")

    @property
    @pulumi.getter(name="lowImportanceFailingCount")
    def low_importance_failing_count(self) -> Optional[int]:
        """
        The low importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_failing_count")

    @property
    @pulumi.getter(name="lowImportanceWarningCount")
    def low_importance_warning_count(self) -> Optional[int]:
        """
        The low importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_warning_count")

    @property
    @pulumi.getter(name="starredFeatures")
    def starred_features(self) -> Optional[Sequence[str]]:
        """
        The starred features for the data drift health settings.
        """
        return pulumi.get(self, "starred_features")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        The time interval for the data drift health settings.
        """
        return pulumi.get(self, "time_interval")


@pulumi.output_type
class DeploymentHealthSettingsFairness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protectedClassFailingCount":
            suggest = "protected_class_failing_count"
        elif key == "protectedClassWarningCount":
            suggest = "protected_class_warning_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsFairness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsFairness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsFairness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protected_class_failing_count: Optional[int] = None,
                 protected_class_warning_count: Optional[int] = None):
        """
        :param int protected_class_failing_count: The protected class failing count for the fairness health settings.
        :param int protected_class_warning_count: The protected class warning count for the fairness health settings.
        """
        if protected_class_failing_count is not None:
            pulumi.set(__self__, "protected_class_failing_count", protected_class_failing_count)
        if protected_class_warning_count is not None:
            pulumi.set(__self__, "protected_class_warning_count", protected_class_warning_count)

    @property
    @pulumi.getter(name="protectedClassFailingCount")
    def protected_class_failing_count(self) -> Optional[int]:
        """
        The protected class failing count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_failing_count")

    @property
    @pulumi.getter(name="protectedClassWarningCount")
    def protected_class_warning_count(self) -> Optional[int]:
        """
        The protected class warning count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_warning_count")


@pulumi.output_type
class DeploymentHealthSettingsPredictionsTimeliness(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedFrequency":
            suggest = "expected_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsPredictionsTimeliness. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsPredictionsTimeliness.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsPredictionsTimeliness.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 expected_frequency: Optional[str] = None):
        """
        :param bool enabled: If predictions timeliness is enabled for this Deployment.
        :param str expected_frequency: The expected frequency for the predictions timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If predictions timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[str]:
        """
        The expected frequency for the predictions timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")


@pulumi.output_type
class DeploymentHealthSettingsService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCount":
            suggest = "batch_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentHealthSettingsService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentHealthSettingsService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentHealthSettingsService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_count: int):
        """
        :param int batch_count: The batch count for the service health settings.
        """
        pulumi.set(__self__, "batch_count", batch_count)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> int:
        """
        The batch count for the service health settings.
        """
        return pulumi.get(self, "batch_count")


@pulumi.output_type
class DeploymentPredictionIntervalsSettings(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percentiles: Optional[Sequence[int]] = None):
        """
        :param bool enabled: Whether prediction intervals are enabled for this deployment.
        :param Sequence[int] percentiles: List of enabled prediction intervals sizes for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)
        if percentiles is not None:
            pulumi.set(__self__, "percentiles", percentiles)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether prediction intervals are enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percentiles(self) -> Optional[Sequence[int]]:
        """
        List of enabled prediction intervals sizes for this deployment.
        """
        return pulumi.get(self, "percentiles")


@pulumi.output_type
class DeploymentPredictionWarningSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBoundaries":
            suggest = "custom_boundaries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentPredictionWarningSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentPredictionWarningSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentPredictionWarningSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_boundaries: Optional['outputs.DeploymentPredictionWarningSettingsCustomBoundaries'] = None):
        """
        :param bool enabled: If target prediction warning is enabled for this Deployment.
        :param 'DeploymentPredictionWarningSettingsCustomBoundariesArgs' custom_boundaries: The custom boundaries for prediction warnings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_boundaries is not None:
            pulumi.set(__self__, "custom_boundaries", custom_boundaries)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If target prediction warning is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customBoundaries")
    def custom_boundaries(self) -> Optional['outputs.DeploymentPredictionWarningSettingsCustomBoundaries']:
        """
        The custom boundaries for prediction warnings.
        """
        return pulumi.get(self, "custom_boundaries")


@pulumi.output_type
class DeploymentPredictionWarningSettingsCustomBoundaries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentPredictionWarningSettingsCustomBoundaries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentPredictionWarningSettingsCustomBoundaries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentPredictionWarningSettingsCustomBoundaries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lower_boundary: Optional[float] = None,
                 upper_boundary: Optional[float] = None):
        """
        :param float lower_boundary: All predictions less than provided value will be considered anomalous.
        :param float upper_boundary: All predictions greater than provided value will be considered anomalous.
        """
        if lower_boundary is not None:
            pulumi.set(__self__, "lower_boundary", lower_boundary)
        if upper_boundary is not None:
            pulumi.set(__self__, "upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        """
        All predictions less than provided value will be considered anomalous.
        """
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        """
        All predictions greater than provided value will be considered anomalous.
        """
        return pulumi.get(self, "upper_boundary")


@pulumi.output_type
class DeploymentPredictionsByForecastDateSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "datetimeFormat":
            suggest = "datetime_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentPredictionsByForecastDateSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentPredictionsByForecastDateSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentPredictionsByForecastDateSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 column_name: Optional[str] = None,
                 datetime_format: Optional[str] = None):
        """
        :param bool enabled: Is True if predictions by forecast date is enabled for this deployment.
        :param str column_name: The column name in prediction datasets to be used as forecast date.
        :param str datetime_format: The datetime format of the forecast date column in prediction datasets.
        """
        pulumi.set(__self__, "enabled", enabled)
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if datetime_format is not None:
            pulumi.set(__self__, "datetime_format", datetime_format)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is True if predictions by forecast date is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        The column name in prediction datasets to be used as forecast date.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[str]:
        """
        The datetime format of the forecast date column in prediction datasets.
        """
        return pulumi.get(self, "datetime_format")


@pulumi.output_type
class DeploymentPredictionsDataCollectionSettings(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: If predictions data collections is enabled for this Deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If predictions data collections is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeploymentPredictionsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxComputes":
            suggest = "max_computes"
        elif key == "minComputes":
            suggest = "min_computes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentPredictionsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentPredictionsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentPredictionsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_computes: int,
                 min_computes: int):
        """
        :param int max_computes: The maximum number of computes to use for predictions.
        :param int min_computes: The minimum number of computes to use for predictions.
        """
        pulumi.set(__self__, "max_computes", max_computes)
        pulumi.set(__self__, "min_computes", min_computes)

    @property
    @pulumi.getter(name="maxComputes")
    def max_computes(self) -> int:
        """
        The maximum number of computes to use for predictions.
        """
        return pulumi.get(self, "max_computes")

    @property
    @pulumi.getter(name="minComputes")
    def min_computes(self) -> int:
        """
        The minimum number of computes to use for predictions.
        """
        return pulumi.get(self, "min_computes")


@pulumi.output_type
class DeploymentSegmentAnalysisSettings(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 attributes: Optional[Sequence[str]] = None):
        """
        :param bool enabled: Set to 'True' if segment analysis is enabled for this deployment.
        :param Sequence[str] attributes: A list of strings that gives the segment attributes selected for tracking.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Set to 'True' if segment analysis is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[str]]:
        """
        A list of strings that gives the segment attributes selected for tracking.
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class LlmBlueprintLlmSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCompletionLength":
            suggest = "max_completion_length"
        elif key == "systemPrompt":
            suggest = "system_prompt"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LlmBlueprintLlmSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LlmBlueprintLlmSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LlmBlueprintLlmSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_completion_length: Optional[int] = None,
                 system_prompt: Optional[str] = None,
                 temperature: Optional[float] = None,
                 top_p: Optional[float] = None):
        """
        :param int max_completion_length: The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        :param str system_prompt: Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        :param float temperature: Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        :param float top_p: Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        if max_completion_length is not None:
            pulumi.set(__self__, "max_completion_length", max_completion_length)
        if system_prompt is not None:
            pulumi.set(__self__, "system_prompt", system_prompt)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxCompletionLength")
    def max_completion_length(self) -> Optional[int]:
        """
        The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        """
        return pulumi.get(self, "max_completion_length")

    @property
    @pulumi.getter(name="systemPrompt")
    def system_prompt(self) -> Optional[str]:
        """
        Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        return pulumi.get(self, "system_prompt")

    @property
    @pulumi.getter
    def temperature(self) -> Optional[float]:
        """
        Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        """
        return pulumi.get(self, "temperature")

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[float]:
        """
        Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class LlmBlueprintVectorDatabaseSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDocumentsRetrievedPerPrompt":
            suggest = "max_documents_retrieved_per_prompt"
        elif key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LlmBlueprintVectorDatabaseSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LlmBlueprintVectorDatabaseSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LlmBlueprintVectorDatabaseSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_documents_retrieved_per_prompt: Optional[int] = None,
                 max_tokens: Optional[int] = None):
        """
        :param int max_documents_retrieved_per_prompt: The maximum number of documents to retrieve from the Vector Database.
        :param int max_tokens: The maximum number of tokens to retrieve from the Vector Database.
        """
        if max_documents_retrieved_per_prompt is not None:
            pulumi.set(__self__, "max_documents_retrieved_per_prompt", max_documents_retrieved_per_prompt)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxDocumentsRetrievedPerPrompt")
    def max_documents_retrieved_per_prompt(self) -> Optional[int]:
        """
        The maximum number of documents to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_documents_retrieved_per_prompt")

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[int]:
        """
        The maximum number of tokens to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class VectorDatabaseChunkingParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkOverlapPercentage":
            suggest = "chunk_overlap_percentage"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkingMethod":
            suggest = "chunking_method"
        elif key == "embeddingModel":
            suggest = "embedding_model"
        elif key == "isSeparatorRegex":
            suggest = "is_separator_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorDatabaseChunkingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorDatabaseChunkingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorDatabaseChunkingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_overlap_percentage: Optional[int] = None,
                 chunk_size: Optional[int] = None,
                 chunking_method: Optional[str] = None,
                 embedding_model: Optional[str] = None,
                 is_separator_regex: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param int chunk_overlap_percentage: The percentage of overlap between chunks.
        :param int chunk_size: The size of the chunks.
        :param str chunking_method: The method used to chunk the data.
        :param str embedding_model: The id of the Embedding Model.
        :param bool is_separator_regex: Whether the separator is a regex.
        :param Sequence[str] separators: The separators used to split the data.
        """
        if chunk_overlap_percentage is not None:
            pulumi.set(__self__, "chunk_overlap_percentage", chunk_overlap_percentage)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if chunking_method is not None:
            pulumi.set(__self__, "chunking_method", chunking_method)
        if embedding_model is not None:
            pulumi.set(__self__, "embedding_model", embedding_model)
        if is_separator_regex is not None:
            pulumi.set(__self__, "is_separator_regex", is_separator_regex)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="chunkOverlapPercentage")
    def chunk_overlap_percentage(self) -> Optional[int]:
        """
        The percentage of overlap between chunks.
        """
        return pulumi.get(self, "chunk_overlap_percentage")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[int]:
        """
        The size of the chunks.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkingMethod")
    def chunking_method(self) -> Optional[str]:
        """
        The method used to chunk the data.
        """
        return pulumi.get(self, "chunking_method")

    @property
    @pulumi.getter(name="embeddingModel")
    def embedding_model(self) -> Optional[str]:
        """
        The id of the Embedding Model.
        """
        return pulumi.get(self, "embedding_model")

    @property
    @pulumi.getter(name="isSeparatorRegex")
    def is_separator_regex(self) -> Optional[bool]:
        """
        Whether the separator is a regex.
        """
        return pulumi.get(self, "is_separator_regex")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        The separators used to split the data.
        """
        return pulumi.get(self, "separators")


