# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApplicationSourceFromTemplateResourcesArgs',
    'ApplicationSourceFromTemplateResourcesArgsDict',
    'ApplicationSourceFromTemplateRuntimeParameterValueArgs',
    'ApplicationSourceFromTemplateRuntimeParameterValueArgsDict',
    'ApplicationSourceResourcesArgs',
    'ApplicationSourceResourcesArgsDict',
    'ApplicationSourceRuntimeParameterValueArgs',
    'ApplicationSourceRuntimeParameterValueArgsDict',
    'BatchPredictionJobDefinitionCsvSettingsArgs',
    'BatchPredictionJobDefinitionCsvSettingsArgsDict',
    'BatchPredictionJobDefinitionIntakeSettingsArgs',
    'BatchPredictionJobDefinitionIntakeSettingsArgsDict',
    'BatchPredictionJobDefinitionOutputSettingsArgs',
    'BatchPredictionJobDefinitionOutputSettingsArgsDict',
    'BatchPredictionJobDefinitionPredictionInstanceArgs',
    'BatchPredictionJobDefinitionPredictionInstanceArgsDict',
    'BatchPredictionJobDefinitionScheduleArgs',
    'BatchPredictionJobDefinitionScheduleArgsDict',
    'BatchPredictionJobDefinitionTimeseriesSettingsArgs',
    'BatchPredictionJobDefinitionTimeseriesSettingsArgsDict',
    'CustomJobRuntimeParameterValueArgs',
    'CustomJobRuntimeParameterValueArgsDict',
    'CustomJobScheduleArgs',
    'CustomJobScheduleArgsDict',
    'CustomMetricBatchArgs',
    'CustomMetricBatchArgsDict',
    'CustomMetricFromJobBatchArgs',
    'CustomMetricFromJobBatchArgsDict',
    'CustomMetricFromJobParameterOverrideArgs',
    'CustomMetricFromJobParameterOverrideArgsDict',
    'CustomMetricFromJobSampleCountArgs',
    'CustomMetricFromJobSampleCountArgsDict',
    'CustomMetricFromJobScheduleArgs',
    'CustomMetricFromJobScheduleArgsDict',
    'CustomMetricFromJobTimestampArgs',
    'CustomMetricFromJobTimestampArgsDict',
    'CustomMetricFromJobValueArgs',
    'CustomMetricFromJobValueArgsDict',
    'CustomMetricJobRuntimeParameterValueArgs',
    'CustomMetricJobRuntimeParameterValueArgsDict',
    'CustomMetricSampleCountArgs',
    'CustomMetricSampleCountArgsDict',
    'CustomMetricTimestampArgs',
    'CustomMetricTimestampArgsDict',
    'CustomMetricValueArgs',
    'CustomMetricValueArgsDict',
    'CustomModelGuardConfigurationArgs',
    'CustomModelGuardConfigurationArgsDict',
    'CustomModelGuardConfigurationInterventionArgs',
    'CustomModelGuardConfigurationInterventionArgsDict',
    'CustomModelGuardConfigurationNemoInfoArgs',
    'CustomModelGuardConfigurationNemoInfoArgsDict',
    'CustomModelOverallModerationConfigurationArgs',
    'CustomModelOverallModerationConfigurationArgsDict',
    'CustomModelRuntimeParameterValueArgs',
    'CustomModelRuntimeParameterValueArgsDict',
    'CustomModelSourceRemoteRepositoryArgs',
    'CustomModelSourceRemoteRepositoryArgsDict',
    'DatasourceParamsArgs',
    'DatasourceParamsArgsDict',
    'DeploymentAssociationIdSettingsArgs',
    'DeploymentAssociationIdSettingsArgsDict',
    'DeploymentBatchMonitoringSettingsArgs',
    'DeploymentBatchMonitoringSettingsArgsDict',
    'DeploymentBiasAndFairnessSettingsArgs',
    'DeploymentBiasAndFairnessSettingsArgsDict',
    'DeploymentChallengerModelsSettingsArgs',
    'DeploymentChallengerModelsSettingsArgsDict',
    'DeploymentChallengerReplaySettingsArgs',
    'DeploymentChallengerReplaySettingsArgsDict',
    'DeploymentDriftTrackingSettingsArgs',
    'DeploymentDriftTrackingSettingsArgsDict',
    'DeploymentFeatureCacheSettingsArgs',
    'DeploymentFeatureCacheSettingsArgsDict',
    'DeploymentFeatureCacheSettingsScheduleArgs',
    'DeploymentFeatureCacheSettingsScheduleArgsDict',
    'DeploymentHealthSettingsArgs',
    'DeploymentHealthSettingsArgsDict',
    'DeploymentHealthSettingsAccuracyArgs',
    'DeploymentHealthSettingsAccuracyArgsDict',
    'DeploymentHealthSettingsActualsTimelinessArgs',
    'DeploymentHealthSettingsActualsTimelinessArgsDict',
    'DeploymentHealthSettingsCustomMetricsArgs',
    'DeploymentHealthSettingsCustomMetricsArgsDict',
    'DeploymentHealthSettingsCustomMetricsFailingConditionArgs',
    'DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict',
    'DeploymentHealthSettingsCustomMetricsWarningConditionArgs',
    'DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict',
    'DeploymentHealthSettingsDataDriftArgs',
    'DeploymentHealthSettingsDataDriftArgsDict',
    'DeploymentHealthSettingsFairnessArgs',
    'DeploymentHealthSettingsFairnessArgsDict',
    'DeploymentHealthSettingsPredictionsTimelinessArgs',
    'DeploymentHealthSettingsPredictionsTimelinessArgsDict',
    'DeploymentHealthSettingsServiceArgs',
    'DeploymentHealthSettingsServiceArgsDict',
    'DeploymentPredictionIntervalsSettingsArgs',
    'DeploymentPredictionIntervalsSettingsArgsDict',
    'DeploymentPredictionWarningSettingsArgs',
    'DeploymentPredictionWarningSettingsArgsDict',
    'DeploymentPredictionWarningSettingsCustomBoundariesArgs',
    'DeploymentPredictionWarningSettingsCustomBoundariesArgsDict',
    'DeploymentPredictionsByForecastDateSettingsArgs',
    'DeploymentPredictionsByForecastDateSettingsArgsDict',
    'DeploymentPredictionsDataCollectionSettingsArgs',
    'DeploymentPredictionsDataCollectionSettingsArgsDict',
    'DeploymentPredictionsSettingsArgs',
    'DeploymentPredictionsSettingsArgsDict',
    'DeploymentRetrainingPolicyAutopilotOptionsArgs',
    'DeploymentRetrainingPolicyAutopilotOptionsArgsDict',
    'DeploymentRetrainingPolicyProjectOptionsArgs',
    'DeploymentRetrainingPolicyProjectOptionsArgsDict',
    'DeploymentRetrainingPolicyTimeSeriesOptionsArgs',
    'DeploymentRetrainingPolicyTimeSeriesOptionsArgsDict',
    'DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs',
    'DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgsDict',
    'DeploymentRetrainingPolicyTriggerArgs',
    'DeploymentRetrainingPolicyTriggerArgsDict',
    'DeploymentRetrainingPolicyTriggerScheduleArgs',
    'DeploymentRetrainingPolicyTriggerScheduleArgsDict',
    'DeploymentRetrainingSettingsArgs',
    'DeploymentRetrainingSettingsArgsDict',
    'DeploymentRuntimeParameterValueArgs',
    'DeploymentRuntimeParameterValueArgsDict',
    'DeploymentSegmentAnalysisSettingsArgs',
    'DeploymentSegmentAnalysisSettingsArgsDict',
    'LlmBlueprintCustomModelLlmSettingsArgs',
    'LlmBlueprintCustomModelLlmSettingsArgsDict',
    'LlmBlueprintLlmSettingsArgs',
    'LlmBlueprintLlmSettingsArgsDict',
    'LlmBlueprintVectorDatabaseSettingsArgs',
    'LlmBlueprintVectorDatabaseSettingsArgsDict',
    'NotificationChannelCustomHeaderArgs',
    'NotificationChannelCustomHeaderArgsDict',
    'NotificationChannelDrEntityArgs',
    'NotificationChannelDrEntityArgsDict',
    'VectorDatabaseChunkingParametersArgs',
    'VectorDatabaseChunkingParametersArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationSourceFromTemplateResourcesArgsDict(TypedDict):
        replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        The replicas for the Application Source.
        """
        resource_label: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource label for the Application Source.
        """
        session_affinity: NotRequired[pulumi.Input[builtins.bool]]
        """
        The session affinity for the Application Source.
        """
elif False:
    ApplicationSourceFromTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceFromTemplateResourcesArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[builtins.int]] = None,
                 resource_label: Optional[pulumi.Input[builtins.str]] = None,
                 session_affinity: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] replicas: The replicas for the Application Source.
        :param pulumi.Input[builtins.str] resource_label: The resource label for the Application Source.
        :param pulumi.Input[builtins.bool] session_affinity: The session affinity for the Application Source.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The replicas for the Application Source.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource label for the Application Source.
        """
        return pulumi.get(self, "resource_label")

    @resource_label.setter
    def resource_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_label", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The session affinity for the Application Source.
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "session_affinity", value)


if not MYPY:
    class ApplicationSourceFromTemplateRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    ApplicationSourceFromTemplateRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceFromTemplateRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationSourceResourcesArgsDict(TypedDict):
        replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        The replicas for the Application Source.
        """
        resource_label: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource label for the Application Source.
        """
        session_affinity: NotRequired[pulumi.Input[builtins.bool]]
        """
        The session affinity for the Application Source.
        """
elif False:
    ApplicationSourceResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceResourcesArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[builtins.int]] = None,
                 resource_label: Optional[pulumi.Input[builtins.str]] = None,
                 session_affinity: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] replicas: The replicas for the Application Source.
        :param pulumi.Input[builtins.str] resource_label: The resource label for the Application Source.
        :param pulumi.Input[builtins.bool] session_affinity: The session affinity for the Application Source.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The replicas for the Application Source.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource label for the Application Source.
        """
        return pulumi.get(self, "resource_label")

    @resource_label.setter
    def resource_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_label", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The session affinity for the Application Source.
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "session_affinity", value)


if not MYPY:
    class ApplicationSourceRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    ApplicationSourceRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BatchPredictionJobDefinitionCsvSettingsArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[builtins.str]]
        """
        Fields are delimited by this character. Use the string tab to denote TSV (TAB separated values). Must be either a one-character string or the string tab.
        """
        encoding: NotRequired[pulumi.Input[builtins.str]]
        """
        Encoding for the CSV files.
        """
        quotechar: NotRequired[pulumi.Input[builtins.str]]
        """
        Fields containing the delimiter must be quoted using this character.
        """
elif False:
    BatchPredictionJobDefinitionCsvSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionCsvSettingsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[builtins.str]] = None,
                 encoding: Optional[pulumi.Input[builtins.str]] = None,
                 quotechar: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] delimiter: Fields are delimited by this character. Use the string tab to denote TSV (TAB separated values). Must be either a one-character string or the string tab.
        :param pulumi.Input[builtins.str] encoding: Encoding for the CSV files.
        :param pulumi.Input[builtins.str] quotechar: Fields containing the delimiter must be quoted using this character.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if quotechar is not None:
            pulumi.set(__self__, "quotechar", quotechar)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fields are delimited by this character. Use the string tab to denote TSV (TAB separated values). Must be either a one-character string or the string tab.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Encoding for the CSV files.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def quotechar(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fields containing the delimiter must be quoted using this character.
        """
        return pulumi.get(self, "quotechar")

    @quotechar.setter
    def quotechar(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "quotechar", value)


if not MYPY:
    class BatchPredictionJobDefinitionIntakeSettingsArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of data source.
        """
        catalog: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database catalog for JDBC type.
        """
        credential_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the credentials for S3 or JDBC data source.
        """
        data_store_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the external data store connected to the JDBC data source.
        """
        dataset_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the dataset to score for dataset type.
        """
        endpoint_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Any non-default endpoint URL for S3 access.
        """
        fetch_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Changing the fetchSize can be used to balance throughput and memory usage for JDBC type.
        """
        file: NotRequired[pulumi.Input[builtins.str]]
        """
        String path to file of scoring data for localFile type.
        """
        query: NotRequired[pulumi.Input[builtins.str]]
        """
        A self-supplied SELECT statement of the data set you wish to predict for JDBC type.
        """
        schema: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database schema for JDBC type.
        """
        table: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database table for JDBC type.
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL to score (e.g.: s3://bucket/key) for S3 type.
        """
elif False:
    BatchPredictionJobDefinitionIntakeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionIntakeSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 catalog: Optional[pulumi.Input[builtins.str]] = None,
                 credential_id: Optional[pulumi.Input[builtins.str]] = None,
                 data_store_id: Optional[pulumi.Input[builtins.str]] = None,
                 dataset_id: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint_url: Optional[pulumi.Input[builtins.str]] = None,
                 fetch_size: Optional[pulumi.Input[builtins.int]] = None,
                 file: Optional[pulumi.Input[builtins.str]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None,
                 schema: Optional[pulumi.Input[builtins.str]] = None,
                 table: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of data source.
        :param pulumi.Input[builtins.str] catalog: The name of specified database catalog for JDBC type.
        :param pulumi.Input[builtins.str] credential_id: The ID of the credentials for S3 or JDBC data source.
        :param pulumi.Input[builtins.str] data_store_id: The ID of the external data store connected to the JDBC data source.
        :param pulumi.Input[builtins.str] dataset_id: The ID of the dataset to score for dataset type.
        :param pulumi.Input[builtins.str] endpoint_url: Any non-default endpoint URL for S3 access.
        :param pulumi.Input[builtins.int] fetch_size: Changing the fetchSize can be used to balance throughput and memory usage for JDBC type.
        :param pulumi.Input[builtins.str] file: String path to file of scoring data for localFile type.
        :param pulumi.Input[builtins.str] query: A self-supplied SELECT statement of the data set you wish to predict for JDBC type.
        :param pulumi.Input[builtins.str] schema: The name of specified database schema for JDBC type.
        :param pulumi.Input[builtins.str] table: The name of specified database table for JDBC type.
        :param pulumi.Input[builtins.str] url: The URL to score (e.g.: s3://bucket/key) for S3 type.
        """
        pulumi.set(__self__, "type", type)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if data_store_id is not None:
            pulumi.set(__self__, "data_store_id", data_store_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if fetch_size is not None:
            pulumi.set(__self__, "fetch_size", fetch_size)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of data source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database catalog for JDBC type.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the credentials for S3 or JDBC data source.
        """
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="dataStoreId")
    def data_store_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the external data store connected to the JDBC data source.
        """
        return pulumi.get(self, "data_store_id")

    @data_store_id.setter
    def data_store_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_store_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the dataset to score for dataset type.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Any non-default endpoint URL for S3 access.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="fetchSize")
    def fetch_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Changing the fetchSize can be used to balance throughput and memory usage for JDBC type.
        """
        return pulumi.get(self, "fetch_size")

    @fetch_size.setter
    def fetch_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "fetch_size", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String path to file of scoring data for localFile type.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A self-supplied SELECT statement of the data set you wish to predict for JDBC type.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database schema for JDBC type.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database table for JDBC type.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL to score (e.g.: s3://bucket/key) for S3 type.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class BatchPredictionJobDefinitionOutputSettingsArgsDict(TypedDict):
        catalog: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database catalog for JDBC type.
        """
        create_table_if_not_exists: NotRequired[pulumi.Input[builtins.bool]]
        """
        If no existing table is detected, attempt to create it before writing data for JDBC type.
        """
        credential_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the credentials for S3 or JDBC data source.
        """
        data_store_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the external data store connected to the JDBC data source.
        """
        endpoint_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Any non-default endpoint URL for S3 access.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to save the scored data as CSV for localFile type.
        """
        schema: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database schema for JDBC type.
        """
        statement_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of insertion statement to create for JDBC type.
        """
        table: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database table for JDBC type.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of output.
        """
        update_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of strings containing those column names to be updated for JDBC type.
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL for storing the results (e.g.: s3://bucket/key) for S3 type.
        """
        where_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of strings containing those column names to be selected for JDBC type.
        """
elif False:
    BatchPredictionJobDefinitionOutputSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionOutputSettingsArgs:
    def __init__(__self__, *,
                 catalog: Optional[pulumi.Input[builtins.str]] = None,
                 create_table_if_not_exists: Optional[pulumi.Input[builtins.bool]] = None,
                 credential_id: Optional[pulumi.Input[builtins.str]] = None,
                 data_store_id: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint_url: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 schema: Optional[pulumi.Input[builtins.str]] = None,
                 statement_type: Optional[pulumi.Input[builtins.str]] = None,
                 table: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 update_columns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None,
                 where_columns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] catalog: The name of specified database catalog for JDBC type.
        :param pulumi.Input[builtins.bool] create_table_if_not_exists: If no existing table is detected, attempt to create it before writing data for JDBC type.
        :param pulumi.Input[builtins.str] credential_id: The ID of the credentials for S3 or JDBC data source.
        :param pulumi.Input[builtins.str] data_store_id: The ID of the external data store connected to the JDBC data source.
        :param pulumi.Input[builtins.str] endpoint_url: Any non-default endpoint URL for S3 access.
        :param pulumi.Input[builtins.str] path: Path to save the scored data as CSV for localFile type.
        :param pulumi.Input[builtins.str] schema: The name of specified database schema for JDBC type.
        :param pulumi.Input[builtins.str] statement_type: The type of insertion statement to create for JDBC type.
        :param pulumi.Input[builtins.str] table: The name of specified database table for JDBC type.
        :param pulumi.Input[builtins.str] type: Type of output.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] update_columns: A list of strings containing those column names to be updated for JDBC type.
        :param pulumi.Input[builtins.str] url: The URL for storing the results (e.g.: s3://bucket/key) for S3 type.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] where_columns: A list of strings containing those column names to be selected for JDBC type.
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if create_table_if_not_exists is not None:
            pulumi.set(__self__, "create_table_if_not_exists", create_table_if_not_exists)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if data_store_id is not None:
            pulumi.set(__self__, "data_store_id", data_store_id)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if statement_type is not None:
            pulumi.set(__self__, "statement_type", statement_type)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if update_columns is not None:
            pulumi.set(__self__, "update_columns", update_columns)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if where_columns is not None:
            pulumi.set(__self__, "where_columns", where_columns)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database catalog for JDBC type.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="createTableIfNotExists")
    def create_table_if_not_exists(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If no existing table is detected, attempt to create it before writing data for JDBC type.
        """
        return pulumi.get(self, "create_table_if_not_exists")

    @create_table_if_not_exists.setter
    def create_table_if_not_exists(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_table_if_not_exists", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the credentials for S3 or JDBC data source.
        """
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="dataStoreId")
    def data_store_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the external data store connected to the JDBC data source.
        """
        return pulumi.get(self, "data_store_id")

    @data_store_id.setter
    def data_store_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_store_id", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Any non-default endpoint URL for S3 access.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to save the scored data as CSV for localFile type.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database schema for JDBC type.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="statementType")
    def statement_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of insertion statement to create for JDBC type.
        """
        return pulumi.get(self, "statement_type")

    @statement_type.setter
    def statement_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "statement_type", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database table for JDBC type.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of output.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updateColumns")
    def update_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of strings containing those column names to be updated for JDBC type.
        """
        return pulumi.get(self, "update_columns")

    @update_columns.setter
    def update_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "update_columns", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL for storing the results (e.g.: s3://bucket/key) for S3 type.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="whereColumns")
    def where_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of strings containing those column names to be selected for JDBC type.
        """
        return pulumi.get(self, "where_columns")

    @where_columns.setter
    def where_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "where_columns", value)


if not MYPY:
    class BatchPredictionJobDefinitionPredictionInstanceArgsDict(TypedDict):
        host_name: pulumi.Input[builtins.str]
        """
        Hostname of the prediction instance.
        """
        api_key: NotRequired[pulumi.Input[builtins.str]]
        """
        By default, prediction requests will use the API key of the user that created the job. This allows you to make requests on behalf of other users.
        """
        datarobot_key: NotRequired[pulumi.Input[builtins.str]]
        """
        If running a job against a prediction instance in the Managed AI Cloud, you must provide the organization level DataRobot-Key.
        """
        ssl_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to false to run prediction requests from the batch prediction job without SSL. Defaults to true.
        """
elif False:
    BatchPredictionJobDefinitionPredictionInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionPredictionInstanceArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[builtins.str],
                 api_key: Optional[pulumi.Input[builtins.str]] = None,
                 datarobot_key: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] host_name: Hostname of the prediction instance.
        :param pulumi.Input[builtins.str] api_key: By default, prediction requests will use the API key of the user that created the job. This allows you to make requests on behalf of other users.
        :param pulumi.Input[builtins.str] datarobot_key: If running a job against a prediction instance in the Managed AI Cloud, you must provide the organization level DataRobot-Key.
        :param pulumi.Input[builtins.bool] ssl_enabled: Set to false to run prediction requests from the batch prediction job without SSL. Defaults to true.
        """
        pulumi.set(__self__, "host_name", host_name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if datarobot_key is not None:
            pulumi.set(__self__, "datarobot_key", datarobot_key)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[builtins.str]:
        """
        Hostname of the prediction instance.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        By default, prediction requests will use the API key of the user that created the job. This allows you to make requests on behalf of other users.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="datarobotKey")
    def datarobot_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If running a job against a prediction instance in the Managed AI Cloud, you must provide the organization level DataRobot-Key.
        """
        return pulumi.get(self, "datarobot_key")

    @datarobot_key.setter
    def datarobot_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "datarobot_key", value)

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to false to run prediction requests from the batch prediction job without SSL. Defaults to true.
        """
        return pulumi.get(self, "ssl_enabled")

    @ssl_enabled.setter
    def ssl_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl_enabled", value)


if not MYPY:
    class BatchPredictionJobDefinitionScheduleArgsDict(TypedDict):
        day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the month when the job will run.
        """
        day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the week when the job will run.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Hours of the day when the job will run.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Minutes of the day when the job will run.
        """
        months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Months of the year when the job will run.
        """
elif False:
    BatchPredictionJobDefinitionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionScheduleArgs:
    def __init__(__self__, *,
                 day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_months: Days of the month when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_weeks: Days of the week when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hours: Hours of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] minutes: Minutes of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Months of the year when the job will run.
        """
        pulumi.set(__self__, "day_of_months", day_of_months)
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "months", months)

    @property
    @pulumi.getter(name="dayOfMonths")
    def day_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the month when the job will run.
        """
        return pulumi.get(self, "day_of_months")

    @day_of_months.setter
    def day_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_months", value)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the week when the job will run.
        """
        return pulumi.get(self, "day_of_weeks")

    @day_of_weeks.setter
    def day_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Hours of the day when the job will run.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Minutes of the day when the job will run.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Months of the year when the job will run.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "months", value)


if not MYPY:
    class BatchPredictionJobDefinitionTimeseriesSettingsArgsDict(TypedDict):
        forecast_point: NotRequired[pulumi.Input[builtins.str]]
        """
        Forecast point for the dataset, used for the forecast predictions. May be passed if timeseries_settings.type=forecast.
        """
        predictions_end_date: NotRequired[pulumi.Input[builtins.str]]
        """
        End date for historical predictions. May be passed if timeseries_settings.type=historical.
        """
        predictions_start_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Start date for historical predictions. May be passed if timeseries_settings.type=historical.
        """
        relax_known_in_advance_features_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        If True, missing values in the known in advance features are allowed in the forecast window at the prediction time. Default is False.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of time-series prediction. Must be 'forecast' or 'historical'. Default is 'forecast'.
        """
elif False:
    BatchPredictionJobDefinitionTimeseriesSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchPredictionJobDefinitionTimeseriesSettingsArgs:
    def __init__(__self__, *,
                 forecast_point: Optional[pulumi.Input[builtins.str]] = None,
                 predictions_end_date: Optional[pulumi.Input[builtins.str]] = None,
                 predictions_start_date: Optional[pulumi.Input[builtins.str]] = None,
                 relax_known_in_advance_features_check: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] forecast_point: Forecast point for the dataset, used for the forecast predictions. May be passed if timeseries_settings.type=forecast.
        :param pulumi.Input[builtins.str] predictions_end_date: End date for historical predictions. May be passed if timeseries_settings.type=historical.
        :param pulumi.Input[builtins.str] predictions_start_date: Start date for historical predictions. May be passed if timeseries_settings.type=historical.
        :param pulumi.Input[builtins.bool] relax_known_in_advance_features_check: If True, missing values in the known in advance features are allowed in the forecast window at the prediction time. Default is False.
        :param pulumi.Input[builtins.str] type: Type of time-series prediction. Must be 'forecast' or 'historical'. Default is 'forecast'.
        """
        if forecast_point is not None:
            pulumi.set(__self__, "forecast_point", forecast_point)
        if predictions_end_date is not None:
            pulumi.set(__self__, "predictions_end_date", predictions_end_date)
        if predictions_start_date is not None:
            pulumi.set(__self__, "predictions_start_date", predictions_start_date)
        if relax_known_in_advance_features_check is not None:
            pulumi.set(__self__, "relax_known_in_advance_features_check", relax_known_in_advance_features_check)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="forecastPoint")
    def forecast_point(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Forecast point for the dataset, used for the forecast predictions. May be passed if timeseries_settings.type=forecast.
        """
        return pulumi.get(self, "forecast_point")

    @forecast_point.setter
    def forecast_point(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "forecast_point", value)

    @property
    @pulumi.getter(name="predictionsEndDate")
    def predictions_end_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End date for historical predictions. May be passed if timeseries_settings.type=historical.
        """
        return pulumi.get(self, "predictions_end_date")

    @predictions_end_date.setter
    def predictions_end_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "predictions_end_date", value)

    @property
    @pulumi.getter(name="predictionsStartDate")
    def predictions_start_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start date for historical predictions. May be passed if timeseries_settings.type=historical.
        """
        return pulumi.get(self, "predictions_start_date")

    @predictions_start_date.setter
    def predictions_start_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "predictions_start_date", value)

    @property
    @pulumi.getter(name="relaxKnownInAdvanceFeaturesCheck")
    def relax_known_in_advance_features_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If True, missing values in the known in advance features are allowed in the forecast window at the prediction time. Default is False.
        """
        return pulumi.get(self, "relax_known_in_advance_features_check")

    @relax_known_in_advance_features_check.setter
    def relax_known_in_advance_features_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "relax_known_in_advance_features_check", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of time-series prediction. Must be 'forecast' or 'historical'. Default is 'forecast'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomJobRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    CustomJobRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomJobRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomJobScheduleArgsDict(TypedDict):
        day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the month when the job will run.
        """
        day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the week when the job will run.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Hours of the day when the job will run.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Minutes of the day when the job will run.
        """
        months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Months of the year when the job will run.
        """
elif False:
    CustomJobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomJobScheduleArgs:
    def __init__(__self__, *,
                 day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_months: Days of the month when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_weeks: Days of the week when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hours: Hours of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] minutes: Minutes of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Months of the year when the job will run.
        """
        pulumi.set(__self__, "day_of_months", day_of_months)
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "months", months)

    @property
    @pulumi.getter(name="dayOfMonths")
    def day_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the month when the job will run.
        """
        return pulumi.get(self, "day_of_months")

    @day_of_months.setter
    def day_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_months", value)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the week when the job will run.
        """
        return pulumi.get(self, "day_of_weeks")

    @day_of_weeks.setter
    def day_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Hours of the day when the job will run.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Minutes of the day when the job will run.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Months of the year when the job will run.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "months", value)


if not MYPY:
    class CustomMetricBatchArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
elif False:
    CustomMetricBatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricBatchArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomMetricFromJobBatchArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
elif False:
    CustomMetricFromJobBatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobBatchArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomMetricFromJobParameterOverrideArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    CustomMetricFromJobParameterOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobParameterOverrideArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomMetricFromJobSampleCountArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column name.
        """
elif False:
    CustomMetricFromJobSampleCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobSampleCountArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomMetricFromJobScheduleArgsDict(TypedDict):
        day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the month when the metric job will run.
        """
        day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the week when the metric job will run.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Hours of the day when the metric job will run.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Minutes of the day when the metric job will run.
        """
        months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Months of the year when the metric job will run.
        """
elif False:
    CustomMetricFromJobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobScheduleArgs:
    def __init__(__self__, *,
                 day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_months: Days of the month when the metric job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_weeks: Days of the week when the metric job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hours: Hours of the day when the metric job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] minutes: Minutes of the day when the metric job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Months of the year when the metric job will run.
        """
        pulumi.set(__self__, "day_of_months", day_of_months)
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "months", months)

    @property
    @pulumi.getter(name="dayOfMonths")
    def day_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the month when the metric job will run.
        """
        return pulumi.get(self, "day_of_months")

    @day_of_months.setter
    def day_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_months", value)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the week when the metric job will run.
        """
        return pulumi.get(self, "day_of_weeks")

    @day_of_weeks.setter
    def day_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Hours of the day when the metric job will run.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Minutes of the day when the metric job will run.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Months of the year when the metric job will run.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "months", value)


if not MYPY:
    class CustomMetricFromJobTimestampArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
        time_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Format.
        """
elif False:
    CustomMetricFromJobTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobTimestampArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None,
                 time_format: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[builtins.str] time_format: Format.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_format", value)


if not MYPY:
    class CustomMetricFromJobValueArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
elif False:
    CustomMetricFromJobValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricFromJobValueArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomMetricJobRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    CustomMetricJobRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricJobRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomMetricSampleCountArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
elif False:
    CustomMetricSampleCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricSampleCountArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomMetricTimestampArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
        time_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Format.
        """
elif False:
    CustomMetricTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricTimestampArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None,
                 time_format: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[builtins.str] time_format: Format.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Format.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_format", value)


if not MYPY:
    class CustomMetricValueArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
elif False:
    CustomMetricValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomMetricValueArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class CustomModelGuardConfigurationArgsDict(TypedDict):
        intervention: pulumi.Input['CustomModelGuardConfigurationInterventionArgsDict']
        """
        The intervention for the guard configuration.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the guard configuration.
        """
        stages: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The list of stages for the guard configuration.
        """
        template_name: pulumi.Input[builtins.str]
        """
        The template name of the guard configuration.
        """
        deployment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The deployment ID of this guard.
        """
        input_column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The input column name of this guard.
        """
        llm_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The LLM type for this guard.
        """
        nemo_info: NotRequired[pulumi.Input['CustomModelGuardConfigurationNemoInfoArgsDict']]
        """
        Configuration info for NeMo guards.
        """
        openai_api_base: NotRequired[pulumi.Input[builtins.str]]
        """
        The OpenAI API base URL for this guard.
        """
        openai_credential: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of an OpenAI credential for this guard.
        """
        openai_deployment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of an OpenAI deployment for this guard.
        """
        output_column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The output column name of this guard.
        """
elif False:
    CustomModelGuardConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelGuardConfigurationArgs:
    def __init__(__self__, *,
                 intervention: pulumi.Input['CustomModelGuardConfigurationInterventionArgs'],
                 name: pulumi.Input[builtins.str],
                 stages: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 template_name: pulumi.Input[builtins.str],
                 deployment_id: Optional[pulumi.Input[builtins.str]] = None,
                 input_column_name: Optional[pulumi.Input[builtins.str]] = None,
                 llm_type: Optional[pulumi.Input[builtins.str]] = None,
                 nemo_info: Optional[pulumi.Input['CustomModelGuardConfigurationNemoInfoArgs']] = None,
                 openai_api_base: Optional[pulumi.Input[builtins.str]] = None,
                 openai_credential: Optional[pulumi.Input[builtins.str]] = None,
                 openai_deployment_id: Optional[pulumi.Input[builtins.str]] = None,
                 output_column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['CustomModelGuardConfigurationInterventionArgs'] intervention: The intervention for the guard configuration.
        :param pulumi.Input[builtins.str] name: The name of the guard configuration.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] stages: The list of stages for the guard configuration.
        :param pulumi.Input[builtins.str] template_name: The template name of the guard configuration.
        :param pulumi.Input[builtins.str] deployment_id: The deployment ID of this guard.
        :param pulumi.Input[builtins.str] input_column_name: The input column name of this guard.
        :param pulumi.Input[builtins.str] llm_type: The LLM type for this guard.
        :param pulumi.Input['CustomModelGuardConfigurationNemoInfoArgs'] nemo_info: Configuration info for NeMo guards.
        :param pulumi.Input[builtins.str] openai_api_base: The OpenAI API base URL for this guard.
        :param pulumi.Input[builtins.str] openai_credential: The ID of an OpenAI credential for this guard.
        :param pulumi.Input[builtins.str] openai_deployment_id: The ID of an OpenAI deployment for this guard.
        :param pulumi.Input[builtins.str] output_column_name: The output column name of this guard.
        """
        pulumi.set(__self__, "intervention", intervention)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "template_name", template_name)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if input_column_name is not None:
            pulumi.set(__self__, "input_column_name", input_column_name)
        if llm_type is not None:
            pulumi.set(__self__, "llm_type", llm_type)
        if nemo_info is not None:
            pulumi.set(__self__, "nemo_info", nemo_info)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_credential is not None:
            pulumi.set(__self__, "openai_credential", openai_credential)
        if openai_deployment_id is not None:
            pulumi.set(__self__, "openai_deployment_id", openai_deployment_id)
        if output_column_name is not None:
            pulumi.set(__self__, "output_column_name", output_column_name)

    @property
    @pulumi.getter
    def intervention(self) -> pulumi.Input['CustomModelGuardConfigurationInterventionArgs']:
        """
        The intervention for the guard configuration.
        """
        return pulumi.get(self, "intervention")

    @intervention.setter
    def intervention(self, value: pulumi.Input['CustomModelGuardConfigurationInterventionArgs']):
        pulumi.set(self, "intervention", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the guard configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The list of stages for the guard configuration.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "stages", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[builtins.str]:
        """
        The template name of the guard configuration.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "template_name", value)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The deployment ID of this guard.
        """
        return pulumi.get(self, "deployment_id")

    @deployment_id.setter
    def deployment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deployment_id", value)

    @property
    @pulumi.getter(name="inputColumnName")
    def input_column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The input column name of this guard.
        """
        return pulumi.get(self, "input_column_name")

    @input_column_name.setter
    def input_column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "input_column_name", value)

    @property
    @pulumi.getter(name="llmType")
    def llm_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The LLM type for this guard.
        """
        return pulumi.get(self, "llm_type")

    @llm_type.setter
    def llm_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "llm_type", value)

    @property
    @pulumi.getter(name="nemoInfo")
    def nemo_info(self) -> Optional[pulumi.Input['CustomModelGuardConfigurationNemoInfoArgs']]:
        """
        Configuration info for NeMo guards.
        """
        return pulumi.get(self, "nemo_info")

    @nemo_info.setter
    def nemo_info(self, value: Optional[pulumi.Input['CustomModelGuardConfigurationNemoInfoArgs']]):
        pulumi.set(self, "nemo_info", value)

    @property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OpenAI API base URL for this guard.
        """
        return pulumi.get(self, "openai_api_base")

    @openai_api_base.setter
    def openai_api_base(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "openai_api_base", value)

    @property
    @pulumi.getter(name="openaiCredential")
    def openai_credential(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of an OpenAI credential for this guard.
        """
        return pulumi.get(self, "openai_credential")

    @openai_credential.setter
    def openai_credential(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "openai_credential", value)

    @property
    @pulumi.getter(name="openaiDeploymentId")
    def openai_deployment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of an OpenAI deployment for this guard.
        """
        return pulumi.get(self, "openai_deployment_id")

    @openai_deployment_id.setter
    def openai_deployment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "openai_deployment_id", value)

    @property
    @pulumi.getter(name="outputColumnName")
    def output_column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The output column name of this guard.
        """
        return pulumi.get(self, "output_column_name")

    @output_column_name.setter
    def output_column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_column_name", value)


if not MYPY:
    class CustomModelGuardConfigurationInterventionArgsDict(TypedDict):
        action: pulumi.Input[builtins.str]
        """
        The action of the guard intervention.
        """
        condition: pulumi.Input[builtins.str]
        """
        The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        The message of the guard intervention.
        """
elif False:
    CustomModelGuardConfigurationInterventionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelGuardConfigurationInterventionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[builtins.str],
                 condition: pulumi.Input[builtins.str],
                 message: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: The action of the guard intervention.
        :param pulumi.Input[builtins.str] condition: The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        :param pulumi.Input[builtins.str] message: The message of the guard intervention.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[builtins.str]:
        """
        The action of the guard intervention.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The message of the guard intervention.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CustomModelGuardConfigurationNemoInfoArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[builtins.str]]
        """
        The actions for the NeMo information.
        """
        blocked_terms: NotRequired[pulumi.Input[builtins.str]]
        """
        NeMo guardrails blocked terms list.
        """
        llm_prompts: NotRequired[pulumi.Input[builtins.str]]
        """
        NeMo guardrails prompts.
        """
        main_config: NotRequired[pulumi.Input[builtins.str]]
        """
        Overall NeMo configuration YAML.
        """
        rails_config: NotRequired[pulumi.Input[builtins.str]]
        """
        NeMo guardrails configuration Colang.
        """
elif False:
    CustomModelGuardConfigurationNemoInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelGuardConfigurationNemoInfoArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[builtins.str]] = None,
                 blocked_terms: Optional[pulumi.Input[builtins.str]] = None,
                 llm_prompts: Optional[pulumi.Input[builtins.str]] = None,
                 main_config: Optional[pulumi.Input[builtins.str]] = None,
                 rails_config: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] actions: The actions for the NeMo information.
        :param pulumi.Input[builtins.str] blocked_terms: NeMo guardrails blocked terms list.
        :param pulumi.Input[builtins.str] llm_prompts: NeMo guardrails prompts.
        :param pulumi.Input[builtins.str] main_config: Overall NeMo configuration YAML.
        :param pulumi.Input[builtins.str] rails_config: NeMo guardrails configuration Colang.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if blocked_terms is not None:
            pulumi.set(__self__, "blocked_terms", blocked_terms)
        if llm_prompts is not None:
            pulumi.set(__self__, "llm_prompts", llm_prompts)
        if main_config is not None:
            pulumi.set(__self__, "main_config", main_config)
        if rails_config is not None:
            pulumi.set(__self__, "rails_config", rails_config)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The actions for the NeMo information.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="blockedTerms")
    def blocked_terms(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NeMo guardrails blocked terms list.
        """
        return pulumi.get(self, "blocked_terms")

    @blocked_terms.setter
    def blocked_terms(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "blocked_terms", value)

    @property
    @pulumi.getter(name="llmPrompts")
    def llm_prompts(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NeMo guardrails prompts.
        """
        return pulumi.get(self, "llm_prompts")

    @llm_prompts.setter
    def llm_prompts(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "llm_prompts", value)

    @property
    @pulumi.getter(name="mainConfig")
    def main_config(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Overall NeMo configuration YAML.
        """
        return pulumi.get(self, "main_config")

    @main_config.setter
    def main_config(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "main_config", value)

    @property
    @pulumi.getter(name="railsConfig")
    def rails_config(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NeMo guardrails configuration Colang.
        """
        return pulumi.get(self, "rails_config")

    @rails_config.setter
    def rails_config(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rails_config", value)


if not MYPY:
    class CustomModelOverallModerationConfigurationArgsDict(TypedDict):
        timeout_action: NotRequired[pulumi.Input[builtins.str]]
        """
        The timeout action of the overall moderation configuration.
        """
        timeout_sec: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout in seconds of the overall moderation configuration.
        """
elif False:
    CustomModelOverallModerationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOverallModerationConfigurationArgs:
    def __init__(__self__, *,
                 timeout_action: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_sec: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] timeout_action: The timeout action of the overall moderation configuration.
        :param pulumi.Input[builtins.int] timeout_sec: The timeout in seconds of the overall moderation configuration.
        """
        if timeout_action is not None:
            pulumi.set(__self__, "timeout_action", timeout_action)
        if timeout_sec is not None:
            pulumi.set(__self__, "timeout_sec", timeout_sec)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timeout action of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "timeout_action", value)

    @property
    @pulumi.getter(name="timeoutSec")
    def timeout_sec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout in seconds of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_sec")

    @timeout_sec.setter
    def timeout_sec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_sec", value)


if not MYPY:
    class CustomModelRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    CustomModelRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomModelSourceRemoteRepositoryArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The ID of the source remote repository.
        """
        ref: pulumi.Input[builtins.str]
        """
        The reference of the source remote repository.
        """
        source_paths: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The list of source paths in the source remote repository.
        """
elif False:
    CustomModelSourceRemoteRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelSourceRemoteRepositoryArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 ref: pulumi.Input[builtins.str],
                 source_paths: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] id: The ID of the source remote repository.
        :param pulumi.Input[builtins.str] ref: The reference of the source remote repository.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_paths: The list of source paths in the source remote repository.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "source_paths", source_paths)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the source remote repository.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input[builtins.str]:
        """
        The reference of the source remote repository.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ref", value)

    @property
    @pulumi.getter(name="sourcePaths")
    def source_paths(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The list of source paths in the source remote repository.
        """
        return pulumi.get(self, "source_paths")

    @source_paths.setter
    def source_paths(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "source_paths", value)


if not MYPY:
    class DatasourceParamsArgsDict(TypedDict):
        data_store_id: pulumi.Input[builtins.str]
        """
        The id of the DataStore.
        """
        catalog: NotRequired[pulumi.Input[builtins.str]]
        """
        The Catalog name in the database if supported.
        """
        fetch_size: NotRequired[pulumi.Input[builtins.int]]
        """
        A user specified fetch size in the range [1, 20000]. By default a fetchSize will be assigned to balance throughput and memory usage.
        """
        partition_column: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the partition column.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The user-specified path for BLOB storage.
        """
        query: NotRequired[pulumi.Input[builtins.str]]
        """
        The user specified SQL query.
        """
        schema: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the schema associated with the table.
        """
        table: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of specified database table.
        """
elif False:
    DatasourceParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasourceParamsArgs:
    def __init__(__self__, *,
                 data_store_id: pulumi.Input[builtins.str],
                 catalog: Optional[pulumi.Input[builtins.str]] = None,
                 fetch_size: Optional[pulumi.Input[builtins.int]] = None,
                 partition_column: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None,
                 schema: Optional[pulumi.Input[builtins.str]] = None,
                 table: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] data_store_id: The id of the DataStore.
        :param pulumi.Input[builtins.str] catalog: The Catalog name in the database if supported.
        :param pulumi.Input[builtins.int] fetch_size: A user specified fetch size in the range [1, 20000]. By default a fetchSize will be assigned to balance throughput and memory usage.
        :param pulumi.Input[builtins.str] partition_column: The name of the partition column.
        :param pulumi.Input[builtins.str] path: The user-specified path for BLOB storage.
        :param pulumi.Input[builtins.str] query: The user specified SQL query.
        :param pulumi.Input[builtins.str] schema: The name of the schema associated with the table.
        :param pulumi.Input[builtins.str] table: The name of specified database table.
        """
        pulumi.set(__self__, "data_store_id", data_store_id)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if fetch_size is not None:
            pulumi.set(__self__, "fetch_size", fetch_size)
        if partition_column is not None:
            pulumi.set(__self__, "partition_column", partition_column)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="dataStoreId")
    def data_store_id(self) -> pulumi.Input[builtins.str]:
        """
        The id of the DataStore.
        """
        return pulumi.get(self, "data_store_id")

    @data_store_id.setter
    def data_store_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_store_id", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Catalog name in the database if supported.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="fetchSize")
    def fetch_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A user specified fetch size in the range [1, 20000]. By default a fetchSize will be assigned to balance throughput and memory usage.
        """
        return pulumi.get(self, "fetch_size")

    @fetch_size.setter
    def fetch_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "fetch_size", value)

    @property
    @pulumi.getter(name="partitionColumn")
    def partition_column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the partition column.
        """
        return pulumi.get(self, "partition_column")

    @partition_column.setter
    def partition_column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "partition_column", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user-specified path for BLOB storage.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user specified SQL query.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the schema associated with the table.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of specified database table.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table", value)


if not MYPY:
    class DeploymentAssociationIdSettingsArgsDict(TypedDict):
        auto_generate_id: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to auto generate ID.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Name of the columns to be used as association ID, currently only support a list of one string.
        """
        required_in_prediction_requests: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the association ID column is required in prediction requests.
        """
elif False:
    DeploymentAssociationIdSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentAssociationIdSettingsArgs:
    def __init__(__self__, *,
                 auto_generate_id: Optional[pulumi.Input[builtins.bool]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 required_in_prediction_requests: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] auto_generate_id: Whether to auto generate ID.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: Name of the columns to be used as association ID, currently only support a list of one string.
        :param pulumi.Input[builtins.bool] required_in_prediction_requests: Whether the association ID column is required in prediction requests.
        """
        if auto_generate_id is not None:
            pulumi.set(__self__, "auto_generate_id", auto_generate_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if required_in_prediction_requests is not None:
            pulumi.set(__self__, "required_in_prediction_requests", required_in_prediction_requests)

    @property
    @pulumi.getter(name="autoGenerateId")
    def auto_generate_id(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to auto generate ID.
        """
        return pulumi.get(self, "auto_generate_id")

    @auto_generate_id.setter
    def auto_generate_id(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_generate_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Name of the columns to be used as association ID, currently only support a list of one string.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="requiredInPredictionRequests")
    def required_in_prediction_requests(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the association ID column is required in prediction requests.
        """
        return pulumi.get(self, "required_in_prediction_requests")

    @required_in_prediction_requests.setter
    def required_in_prediction_requests(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "required_in_prediction_requests", value)


if not MYPY:
    class DeploymentBatchMonitoringSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If batch monitoring is enabled.
        """
elif False:
    DeploymentBatchMonitoringSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBatchMonitoringSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: If batch monitoring is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If batch monitoring is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentBiasAndFairnessSettingsArgsDict(TypedDict):
        fairness_metric_set: pulumi.Input[builtins.str]
        """
        A set of fairness metrics to use for calculating fairness.
        """
        fairness_threshold: pulumi.Input[builtins.float]
        """
        Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        """
        preferable_target_value: pulumi.Input[builtins.bool]
        """
        A target value that should be treated as a positive outcome for the prediction.
        """
        protected_features: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of features to mark as protected.
        """
elif False:
    DeploymentBiasAndFairnessSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBiasAndFairnessSettingsArgs:
    def __init__(__self__, *,
                 fairness_metric_set: pulumi.Input[builtins.str],
                 fairness_threshold: pulumi.Input[builtins.float],
                 preferable_target_value: pulumi.Input[builtins.bool],
                 protected_features: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] fairness_metric_set: A set of fairness metrics to use for calculating fairness.
        :param pulumi.Input[builtins.float] fairness_threshold: Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        :param pulumi.Input[builtins.bool] preferable_target_value: A target value that should be treated as a positive outcome for the prediction.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protected_features: A list of features to mark as protected.
        """
        pulumi.set(__self__, "fairness_metric_set", fairness_metric_set)
        pulumi.set(__self__, "fairness_threshold", fairness_threshold)
        pulumi.set(__self__, "preferable_target_value", preferable_target_value)
        pulumi.set(__self__, "protected_features", protected_features)

    @property
    @pulumi.getter(name="fairnessMetricSet")
    def fairness_metric_set(self) -> pulumi.Input[builtins.str]:
        """
        A set of fairness metrics to use for calculating fairness.
        """
        return pulumi.get(self, "fairness_metric_set")

    @fairness_metric_set.setter
    def fairness_metric_set(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "fairness_metric_set", value)

    @property
    @pulumi.getter(name="fairnessThreshold")
    def fairness_threshold(self) -> pulumi.Input[builtins.float]:
        """
        Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        """
        return pulumi.get(self, "fairness_threshold")

    @fairness_threshold.setter
    def fairness_threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "fairness_threshold", value)

    @property
    @pulumi.getter(name="preferableTargetValue")
    def preferable_target_value(self) -> pulumi.Input[builtins.bool]:
        """
        A target value that should be treated as a positive outcome for the prediction.
        """
        return pulumi.get(self, "preferable_target_value")

    @preferable_target_value.setter
    def preferable_target_value(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "preferable_target_value", value)

    @property
    @pulumi.getter(name="protectedFeatures")
    def protected_features(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of features to mark as protected.
        """
        return pulumi.get(self, "protected_features")

    @protected_features.setter
    def protected_features(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "protected_features", value)


if not MYPY:
    class DeploymentChallengerModelsSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Is 'True' if challenger models is enabled for this deployment.
        """
elif False:
    DeploymentChallengerModelsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChallengerModelsSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: Is 'True' if challenger models is enabled for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Is 'True' if challenger models is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentChallengerReplaySettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If challenger replay is enabled.
        """
elif False:
    DeploymentChallengerReplaySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChallengerReplaySettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: If challenger replay is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If challenger replay is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentDriftTrackingSettingsArgsDict(TypedDict):
        feature_drift_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If feature drift tracking is to be turned on.
        """
        feature_selection: NotRequired[pulumi.Input[builtins.str]]
        """
        The feature selection method to be used for drift tracking.
        """
        target_drift_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If target drift tracking is to be turned on.
        """
        tracked_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of features to be tracked for drift.
        """
elif False:
    DeploymentDriftTrackingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDriftTrackingSettingsArgs:
    def __init__(__self__, *,
                 feature_drift_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 feature_selection: Optional[pulumi.Input[builtins.str]] = None,
                 target_drift_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 tracked_features: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] feature_drift_enabled: If feature drift tracking is to be turned on.
        :param pulumi.Input[builtins.str] feature_selection: The feature selection method to be used for drift tracking.
        :param pulumi.Input[builtins.bool] target_drift_enabled: If target drift tracking is to be turned on.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tracked_features: List of features to be tracked for drift.
        """
        if feature_drift_enabled is not None:
            pulumi.set(__self__, "feature_drift_enabled", feature_drift_enabled)
        if feature_selection is not None:
            pulumi.set(__self__, "feature_selection", feature_selection)
        if target_drift_enabled is not None:
            pulumi.set(__self__, "target_drift_enabled", target_drift_enabled)
        if tracked_features is not None:
            pulumi.set(__self__, "tracked_features", tracked_features)

    @property
    @pulumi.getter(name="featureDriftEnabled")
    def feature_drift_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If feature drift tracking is to be turned on.
        """
        return pulumi.get(self, "feature_drift_enabled")

    @feature_drift_enabled.setter
    def feature_drift_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "feature_drift_enabled", value)

    @property
    @pulumi.getter(name="featureSelection")
    def feature_selection(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The feature selection method to be used for drift tracking.
        """
        return pulumi.get(self, "feature_selection")

    @feature_selection.setter
    def feature_selection(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "feature_selection", value)

    @property
    @pulumi.getter(name="targetDriftEnabled")
    def target_drift_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If target drift tracking is to be turned on.
        """
        return pulumi.get(self, "target_drift_enabled")

    @target_drift_enabled.setter
    def target_drift_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "target_drift_enabled", value)

    @property
    @pulumi.getter(name="trackedFeatures")
    def tracked_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of features to be tracked for drift.
        """
        return pulumi.get(self, "tracked_features")

    @tracked_features.setter
    def tracked_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tracked_features", value)


if not MYPY:
    class DeploymentFeatureCacheSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If feature cache is enabled for this Deployment.
        """
        fetching: NotRequired[pulumi.Input[builtins.bool]]
        """
        If feature cache fetching is enabled.
        """
        schedule: NotRequired[pulumi.Input['DeploymentFeatureCacheSettingsScheduleArgsDict']]
        """
        Defines the feature cache schedule.
        """
elif False:
    DeploymentFeatureCacheSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentFeatureCacheSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 fetching: Optional[pulumi.Input[builtins.bool]] = None,
                 schedule: Optional[pulumi.Input['DeploymentFeatureCacheSettingsScheduleArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: If feature cache is enabled for this Deployment.
        :param pulumi.Input[builtins.bool] fetching: If feature cache fetching is enabled.
        :param pulumi.Input['DeploymentFeatureCacheSettingsScheduleArgs'] schedule: Defines the feature cache schedule.
        """
        pulumi.set(__self__, "enabled", enabled)
        if fetching is not None:
            pulumi.set(__self__, "fetching", fetching)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If feature cache is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fetching(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If feature cache fetching is enabled.
        """
        return pulumi.get(self, "fetching")

    @fetching.setter
    def fetching(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fetching", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['DeploymentFeatureCacheSettingsScheduleArgs']]:
        """
        Defines the feature cache schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['DeploymentFeatureCacheSettingsScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class DeploymentFeatureCacheSettingsScheduleArgsDict(TypedDict):
        day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the month.
        """
        day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the week.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Hours of the day.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Minutes of the day.
        """
        months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Months of the year.
        """
elif False:
    DeploymentFeatureCacheSettingsScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentFeatureCacheSettingsScheduleArgs:
    def __init__(__self__, *,
                 day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_months: Days of the month.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_weeks: Days of the week.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hours: Hours of the day.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] minutes: Minutes of the day.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Months of the year.
        """
        pulumi.set(__self__, "day_of_months", day_of_months)
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "months", months)

    @property
    @pulumi.getter(name="dayOfMonths")
    def day_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the month.
        """
        return pulumi.get(self, "day_of_months")

    @day_of_months.setter
    def day_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_months", value)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @day_of_weeks.setter
    def day_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Hours of the day.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Minutes of the day.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Months of the year.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "months", value)


if not MYPY:
    class DeploymentHealthSettingsArgsDict(TypedDict):
        accuracy: NotRequired[pulumi.Input['DeploymentHealthSettingsAccuracyArgsDict']]
        """
        The accuracy health settings for this Deployment.
        """
        actuals_timeliness: NotRequired[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgsDict']]
        """
        The actuals timeliness health settings for this Deployment.
        """
        custom_metrics: NotRequired[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgsDict']]
        """
        The custom metrics health settings for this Deployment.
        """
        data_drift: NotRequired[pulumi.Input['DeploymentHealthSettingsDataDriftArgsDict']]
        """
        The data drift health settings for this Deployment.
        """
        fairness: NotRequired[pulumi.Input['DeploymentHealthSettingsFairnessArgsDict']]
        """
        The fairness health settings for this Deployment.
        """
        predictions_timeliness: NotRequired[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgsDict']]
        """
        The predictions timeliness health settings for this Deployment.
        """
        service: NotRequired[pulumi.Input['DeploymentHealthSettingsServiceArgsDict']]
        """
        The service health settings for this Deployment.
        """
elif False:
    DeploymentHealthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsArgs:
    def __init__(__self__, *,
                 accuracy: Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']] = None,
                 actuals_timeliness: Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']] = None,
                 custom_metrics: Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']] = None,
                 data_drift: Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']] = None,
                 fairness: Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']] = None,
                 predictions_timeliness: Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']] = None,
                 service: Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']] = None):
        """
        :param pulumi.Input['DeploymentHealthSettingsAccuracyArgs'] accuracy: The accuracy health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs'] actuals_timeliness: The actuals timeliness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs'] custom_metrics: The custom metrics health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsDataDriftArgs'] data_drift: The data drift health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsFairnessArgs'] fairness: The fairness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs'] predictions_timeliness: The predictions timeliness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsServiceArgs'] service: The service health settings for this Deployment.
        """
        if accuracy is not None:
            pulumi.set(__self__, "accuracy", accuracy)
        if actuals_timeliness is not None:
            pulumi.set(__self__, "actuals_timeliness", actuals_timeliness)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if data_drift is not None:
            pulumi.set(__self__, "data_drift", data_drift)
        if fairness is not None:
            pulumi.set(__self__, "fairness", fairness)
        if predictions_timeliness is not None:
            pulumi.set(__self__, "predictions_timeliness", predictions_timeliness)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def accuracy(self) -> Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']]:
        """
        The accuracy health settings for this Deployment.
        """
        return pulumi.get(self, "accuracy")

    @accuracy.setter
    def accuracy(self, value: Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']]):
        pulumi.set(self, "accuracy", value)

    @property
    @pulumi.getter(name="actualsTimeliness")
    def actuals_timeliness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']]:
        """
        The actuals timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "actuals_timeliness")

    @actuals_timeliness.setter
    def actuals_timeliness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']]):
        pulumi.set(self, "actuals_timeliness", value)

    @property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']]:
        """
        The custom metrics health settings for this Deployment.
        """
        return pulumi.get(self, "custom_metrics")

    @custom_metrics.setter
    def custom_metrics(self, value: Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']]):
        pulumi.set(self, "custom_metrics", value)

    @property
    @pulumi.getter(name="dataDrift")
    def data_drift(self) -> Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']]:
        """
        The data drift health settings for this Deployment.
        """
        return pulumi.get(self, "data_drift")

    @data_drift.setter
    def data_drift(self, value: Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']]):
        pulumi.set(self, "data_drift", value)

    @property
    @pulumi.getter
    def fairness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']]:
        """
        The fairness health settings for this Deployment.
        """
        return pulumi.get(self, "fairness")

    @fairness.setter
    def fairness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']]):
        pulumi.set(self, "fairness", value)

    @property
    @pulumi.getter(name="predictionsTimeliness")
    def predictions_timeliness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']]:
        """
        The predictions timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "predictions_timeliness")

    @predictions_timeliness.setter
    def predictions_timeliness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']]):
        pulumi.set(self, "predictions_timeliness", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']]:
        """
        The service health settings for this Deployment.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']]):
        pulumi.set(self, "service", value)


if not MYPY:
    class DeploymentHealthSettingsAccuracyArgsDict(TypedDict):
        batch_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The batch count for the accuracy health settings.
        """
        failing_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The failing threshold for the accuracy health settings.
        """
        measurement: NotRequired[pulumi.Input[builtins.str]]
        """
        The measurement for the accuracy health settings.
        """
        metric: NotRequired[pulumi.Input[builtins.str]]
        """
        The metric for the accuracy health settings.
        """
        warning_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The warning threshold for the accuracy health settings.
        """
elif False:
    DeploymentHealthSettingsAccuracyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsAccuracyArgs:
    def __init__(__self__, *,
                 batch_count: Optional[pulumi.Input[builtins.int]] = None,
                 failing_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 measurement: Optional[pulumi.Input[builtins.str]] = None,
                 metric: Optional[pulumi.Input[builtins.str]] = None,
                 warning_threshold: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.int] batch_count: The batch count for the accuracy health settings.
        :param pulumi.Input[builtins.float] failing_threshold: The failing threshold for the accuracy health settings.
        :param pulumi.Input[builtins.str] measurement: The measurement for the accuracy health settings.
        :param pulumi.Input[builtins.str] metric: The metric for the accuracy health settings.
        :param pulumi.Input[builtins.float] warning_threshold: The warning threshold for the accuracy health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if failing_threshold is not None:
            pulumi.set(__self__, "failing_threshold", failing_threshold)
        if measurement is not None:
            pulumi.set(__self__, "measurement", measurement)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if warning_threshold is not None:
            pulumi.set(__self__, "warning_threshold", warning_threshold)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The batch count for the accuracy health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="failingThreshold")
    def failing_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The failing threshold for the accuracy health settings.
        """
        return pulumi.get(self, "failing_threshold")

    @failing_threshold.setter
    def failing_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "failing_threshold", value)

    @property
    @pulumi.getter
    def measurement(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The measurement for the accuracy health settings.
        """
        return pulumi.get(self, "measurement")

    @measurement.setter
    def measurement(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "measurement", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The metric for the accuracy health settings.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="warningThreshold")
    def warning_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The warning threshold for the accuracy health settings.
        """
        return pulumi.get(self, "warning_threshold")

    @warning_threshold.setter
    def warning_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "warning_threshold", value)


if not MYPY:
    class DeploymentHealthSettingsActualsTimelinessArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If acutals timeliness is enabled for this Deployment.
        """
        expected_frequency: NotRequired[pulumi.Input[builtins.str]]
        """
        The expected frequency for the actuals timeliness health settings.
        """
elif False:
    DeploymentHealthSettingsActualsTimelinessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsActualsTimelinessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 expected_frequency: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: If acutals timeliness is enabled for this Deployment.
        :param pulumi.Input[builtins.str] expected_frequency: The expected frequency for the actuals timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If acutals timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expected frequency for the actuals timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")

    @expected_frequency.setter
    def expected_frequency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expected_frequency", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsArgsDict(TypedDict):
        failing_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict']]]]
        """
        The failing conditions for the custom metrics health settings.
        """
        warning_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict']]]]
        """
        The warning conditions for the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsArgs:
    def __init__(__self__, *,
                 failing_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]] = None,
                 warning_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]] failing_conditions: The failing conditions for the custom metrics health settings.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]] warning_conditions: The warning conditions for the custom metrics health settings.
        """
        if failing_conditions is not None:
            pulumi.set(__self__, "failing_conditions", failing_conditions)
        if warning_conditions is not None:
            pulumi.set(__self__, "warning_conditions", warning_conditions)

    @property
    @pulumi.getter(name="failingConditions")
    def failing_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]]:
        """
        The failing conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "failing_conditions")

    @failing_conditions.setter
    def failing_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]]):
        pulumi.set(self, "failing_conditions", value)

    @property
    @pulumi.getter(name="warningConditions")
    def warning_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]]:
        """
        The warning conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "warning_conditions")

    @warning_conditions.setter
    def warning_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]]):
        pulumi.set(self, "warning_conditions", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict(TypedDict):
        compare_operator: pulumi.Input[builtins.str]
        """
        The compare operator for the failing condition of the custom metrics health settings.
        """
        metric_id: pulumi.Input[builtins.str]
        """
        The metric ID for the failing condition of the custom metrics health settings.
        """
        threshold: pulumi.Input[builtins.float]
        """
        The threshold for the failing condition of the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsFailingConditionArgs:
    def __init__(__self__, *,
                 compare_operator: pulumi.Input[builtins.str],
                 metric_id: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.str] compare_operator: The compare operator for the failing condition of the custom metrics health settings.
        :param pulumi.Input[builtins.str] metric_id: The metric ID for the failing condition of the custom metrics health settings.
        :param pulumi.Input[builtins.float] threshold: The threshold for the failing condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> pulumi.Input[builtins.str]:
        """
        The compare operator for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @compare_operator.setter
    def compare_operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "compare_operator", value)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> pulumi.Input[builtins.str]:
        """
        The metric ID for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @metric_id.setter
    def metric_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_id", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        """
        The threshold for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict(TypedDict):
        compare_operator: pulumi.Input[builtins.str]
        """
        The compare operator for the warning condition of the custom metrics health settings.
        """
        metric_id: pulumi.Input[builtins.str]
        """
        The metric ID for the warning condition of the custom metrics health settings.
        """
        threshold: pulumi.Input[builtins.float]
        """
        The threshold for the warning condition of the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsWarningConditionArgs:
    def __init__(__self__, *,
                 compare_operator: pulumi.Input[builtins.str],
                 metric_id: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.str] compare_operator: The compare operator for the warning condition of the custom metrics health settings.
        :param pulumi.Input[builtins.str] metric_id: The metric ID for the warning condition of the custom metrics health settings.
        :param pulumi.Input[builtins.float] threshold: The threshold for the warning condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> pulumi.Input[builtins.str]:
        """
        The compare operator for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @compare_operator.setter
    def compare_operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "compare_operator", value)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> pulumi.Input[builtins.str]:
        """
        The metric ID for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @metric_id.setter
    def metric_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_id", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        """
        The threshold for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class DeploymentHealthSettingsDataDriftArgsDict(TypedDict):
        batch_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The batch count for the data drift health settings.
        """
        drift_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The drift threshold for the data drift health settings.
        """
        exclude_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The exclude features for the data drift health settings.
        """
        high_importance_failing_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The high importance failing count for the data drift health settings.
        """
        high_importance_warning_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The high importance warning count for the data drift health settings.
        """
        importance_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The importance threshold for the data drift health settings.
        """
        low_importance_failing_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The low importance failing count for the data drift health settings.
        """
        low_importance_warning_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The low importance warning count for the data drift health settings.
        """
        starred_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The starred features for the data drift health settings.
        """
        time_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        The time interval for the data drift health settings.
        """
elif False:
    DeploymentHealthSettingsDataDriftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsDataDriftArgs:
    def __init__(__self__, *,
                 batch_count: Optional[pulumi.Input[builtins.int]] = None,
                 drift_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 exclude_features: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 high_importance_failing_count: Optional[pulumi.Input[builtins.int]] = None,
                 high_importance_warning_count: Optional[pulumi.Input[builtins.int]] = None,
                 importance_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 low_importance_failing_count: Optional[pulumi.Input[builtins.int]] = None,
                 low_importance_warning_count: Optional[pulumi.Input[builtins.int]] = None,
                 starred_features: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 time_interval: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] batch_count: The batch count for the data drift health settings.
        :param pulumi.Input[builtins.float] drift_threshold: The drift threshold for the data drift health settings.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclude_features: The exclude features for the data drift health settings.
        :param pulumi.Input[builtins.int] high_importance_failing_count: The high importance failing count for the data drift health settings.
        :param pulumi.Input[builtins.int] high_importance_warning_count: The high importance warning count for the data drift health settings.
        :param pulumi.Input[builtins.float] importance_threshold: The importance threshold for the data drift health settings.
        :param pulumi.Input[builtins.int] low_importance_failing_count: The low importance failing count for the data drift health settings.
        :param pulumi.Input[builtins.int] low_importance_warning_count: The low importance warning count for the data drift health settings.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] starred_features: The starred features for the data drift health settings.
        :param pulumi.Input[builtins.str] time_interval: The time interval for the data drift health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if drift_threshold is not None:
            pulumi.set(__self__, "drift_threshold", drift_threshold)
        if exclude_features is not None:
            pulumi.set(__self__, "exclude_features", exclude_features)
        if high_importance_failing_count is not None:
            pulumi.set(__self__, "high_importance_failing_count", high_importance_failing_count)
        if high_importance_warning_count is not None:
            pulumi.set(__self__, "high_importance_warning_count", high_importance_warning_count)
        if importance_threshold is not None:
            pulumi.set(__self__, "importance_threshold", importance_threshold)
        if low_importance_failing_count is not None:
            pulumi.set(__self__, "low_importance_failing_count", low_importance_failing_count)
        if low_importance_warning_count is not None:
            pulumi.set(__self__, "low_importance_warning_count", low_importance_warning_count)
        if starred_features is not None:
            pulumi.set(__self__, "starred_features", starred_features)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The batch count for the data drift health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="driftThreshold")
    def drift_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The drift threshold for the data drift health settings.
        """
        return pulumi.get(self, "drift_threshold")

    @drift_threshold.setter
    def drift_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "drift_threshold", value)

    @property
    @pulumi.getter(name="excludeFeatures")
    def exclude_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The exclude features for the data drift health settings.
        """
        return pulumi.get(self, "exclude_features")

    @exclude_features.setter
    def exclude_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_features", value)

    @property
    @pulumi.getter(name="highImportanceFailingCount")
    def high_importance_failing_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The high importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_failing_count")

    @high_importance_failing_count.setter
    def high_importance_failing_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "high_importance_failing_count", value)

    @property
    @pulumi.getter(name="highImportanceWarningCount")
    def high_importance_warning_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The high importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_warning_count")

    @high_importance_warning_count.setter
    def high_importance_warning_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "high_importance_warning_count", value)

    @property
    @pulumi.getter(name="importanceThreshold")
    def importance_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The importance threshold for the data drift health settings.
        """
        return pulumi.get(self, "importance_threshold")

    @importance_threshold.setter
    def importance_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "importance_threshold", value)

    @property
    @pulumi.getter(name="lowImportanceFailingCount")
    def low_importance_failing_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The low importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_failing_count")

    @low_importance_failing_count.setter
    def low_importance_failing_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "low_importance_failing_count", value)

    @property
    @pulumi.getter(name="lowImportanceWarningCount")
    def low_importance_warning_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The low importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_warning_count")

    @low_importance_warning_count.setter
    def low_importance_warning_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "low_importance_warning_count", value)

    @property
    @pulumi.getter(name="starredFeatures")
    def starred_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The starred features for the data drift health settings.
        """
        return pulumi.get(self, "starred_features")

    @starred_features.setter
    def starred_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "starred_features", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time interval for the data drift health settings.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_interval", value)


if not MYPY:
    class DeploymentHealthSettingsFairnessArgsDict(TypedDict):
        protected_class_failing_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The protected class failing count for the fairness health settings.
        """
        protected_class_warning_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The protected class warning count for the fairness health settings.
        """
elif False:
    DeploymentHealthSettingsFairnessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsFairnessArgs:
    def __init__(__self__, *,
                 protected_class_failing_count: Optional[pulumi.Input[builtins.int]] = None,
                 protected_class_warning_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] protected_class_failing_count: The protected class failing count for the fairness health settings.
        :param pulumi.Input[builtins.int] protected_class_warning_count: The protected class warning count for the fairness health settings.
        """
        if protected_class_failing_count is not None:
            pulumi.set(__self__, "protected_class_failing_count", protected_class_failing_count)
        if protected_class_warning_count is not None:
            pulumi.set(__self__, "protected_class_warning_count", protected_class_warning_count)

    @property
    @pulumi.getter(name="protectedClassFailingCount")
    def protected_class_failing_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The protected class failing count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_failing_count")

    @protected_class_failing_count.setter
    def protected_class_failing_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "protected_class_failing_count", value)

    @property
    @pulumi.getter(name="protectedClassWarningCount")
    def protected_class_warning_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The protected class warning count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_warning_count")

    @protected_class_warning_count.setter
    def protected_class_warning_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "protected_class_warning_count", value)


if not MYPY:
    class DeploymentHealthSettingsPredictionsTimelinessArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If predictions timeliness is enabled for this Deployment.
        """
        expected_frequency: NotRequired[pulumi.Input[builtins.str]]
        """
        The expected frequency for the predictions timeliness health settings.
        """
elif False:
    DeploymentHealthSettingsPredictionsTimelinessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsPredictionsTimelinessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 expected_frequency: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: If predictions timeliness is enabled for this Deployment.
        :param pulumi.Input[builtins.str] expected_frequency: The expected frequency for the predictions timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If predictions timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expected frequency for the predictions timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")

    @expected_frequency.setter
    def expected_frequency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expected_frequency", value)


if not MYPY:
    class DeploymentHealthSettingsServiceArgsDict(TypedDict):
        batch_count: pulumi.Input[builtins.int]
        """
        The batch count for the service health settings.
        """
elif False:
    DeploymentHealthSettingsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsServiceArgs:
    def __init__(__self__, *,
                 batch_count: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] batch_count: The batch count for the service health settings.
        """
        pulumi.set(__self__, "batch_count", batch_count)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> pulumi.Input[builtins.int]:
        """
        The batch count for the service health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "batch_count", value)


if not MYPY:
    class DeploymentPredictionIntervalsSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether prediction intervals are enabled for this deployment.
        """
        percentiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        List of enabled prediction intervals sizes for this deployment.
        """
elif False:
    DeploymentPredictionIntervalsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionIntervalsSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 percentiles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether prediction intervals are enabled for this deployment.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] percentiles: List of enabled prediction intervals sizes for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)
        if percentiles is not None:
            pulumi.set(__self__, "percentiles", percentiles)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether prediction intervals are enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        List of enabled prediction intervals sizes for this deployment.
        """
        return pulumi.get(self, "percentiles")

    @percentiles.setter
    def percentiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "percentiles", value)


if not MYPY:
    class DeploymentPredictionWarningSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If target prediction warning is enabled for this Deployment.
        """
        custom_boundaries: NotRequired[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgsDict']]
        """
        The custom boundaries for prediction warnings.
        """
elif False:
    DeploymentPredictionWarningSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionWarningSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 custom_boundaries: Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: If target prediction warning is enabled for this Deployment.
        :param pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs'] custom_boundaries: The custom boundaries for prediction warnings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_boundaries is not None:
            pulumi.set(__self__, "custom_boundaries", custom_boundaries)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If target prediction warning is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="customBoundaries")
    def custom_boundaries(self) -> Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']]:
        """
        The custom boundaries for prediction warnings.
        """
        return pulumi.get(self, "custom_boundaries")

    @custom_boundaries.setter
    def custom_boundaries(self, value: Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']]):
        pulumi.set(self, "custom_boundaries", value)


if not MYPY:
    class DeploymentPredictionWarningSettingsCustomBoundariesArgsDict(TypedDict):
        lower_boundary: NotRequired[pulumi.Input[builtins.float]]
        """
        All predictions less than provided value will be considered anomalous.
        """
        upper_boundary: NotRequired[pulumi.Input[builtins.float]]
        """
        All predictions greater than provided value will be considered anomalous.
        """
elif False:
    DeploymentPredictionWarningSettingsCustomBoundariesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionWarningSettingsCustomBoundariesArgs:
    def __init__(__self__, *,
                 lower_boundary: Optional[pulumi.Input[builtins.float]] = None,
                 upper_boundary: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] lower_boundary: All predictions less than provided value will be considered anomalous.
        :param pulumi.Input[builtins.float] upper_boundary: All predictions greater than provided value will be considered anomalous.
        """
        if lower_boundary is not None:
            pulumi.set(__self__, "lower_boundary", lower_boundary)
        if upper_boundary is not None:
            pulumi.set(__self__, "upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        All predictions less than provided value will be considered anomalous.
        """
        return pulumi.get(self, "lower_boundary")

    @lower_boundary.setter
    def lower_boundary(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "lower_boundary", value)

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        All predictions greater than provided value will be considered anomalous.
        """
        return pulumi.get(self, "upper_boundary")

    @upper_boundary.setter
    def upper_boundary(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "upper_boundary", value)


if not MYPY:
    class DeploymentPredictionsByForecastDateSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Is True if predictions by forecast date is enabled for this deployment.
        """
        column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The column name in prediction datasets to be used as forecast date.
        """
        datetime_format: NotRequired[pulumi.Input[builtins.str]]
        """
        The datetime format of the forecast date column in prediction datasets.
        """
elif False:
    DeploymentPredictionsByForecastDateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsByForecastDateSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 column_name: Optional[pulumi.Input[builtins.str]] = None,
                 datetime_format: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Is True if predictions by forecast date is enabled for this deployment.
        :param pulumi.Input[builtins.str] column_name: The column name in prediction datasets to be used as forecast date.
        :param pulumi.Input[builtins.str] datetime_format: The datetime format of the forecast date column in prediction datasets.
        """
        pulumi.set(__self__, "enabled", enabled)
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if datetime_format is not None:
            pulumi.set(__self__, "datetime_format", datetime_format)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Is True if predictions by forecast date is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The column name in prediction datasets to be used as forecast date.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The datetime format of the forecast date column in prediction datasets.
        """
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "datetime_format", value)


if not MYPY:
    class DeploymentPredictionsDataCollectionSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        If predictions data collections is enabled for this Deployment.
        """
elif False:
    DeploymentPredictionsDataCollectionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsDataCollectionSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: If predictions data collections is enabled for this Deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        If predictions data collections is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentPredictionsSettingsArgsDict(TypedDict):
        max_computes: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of computes to use for predictions.
        """
        min_computes: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum number of computes to use for predictions.
        """
        resource_bundle_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource bundle ID to use for predictions.
        """
elif False:
    DeploymentPredictionsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsSettingsArgs:
    def __init__(__self__, *,
                 max_computes: Optional[pulumi.Input[builtins.int]] = None,
                 min_computes: Optional[pulumi.Input[builtins.int]] = None,
                 resource_bundle_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] max_computes: The maximum number of computes to use for predictions.
        :param pulumi.Input[builtins.int] min_computes: The minimum number of computes to use for predictions.
        :param pulumi.Input[builtins.str] resource_bundle_id: The resource bundle ID to use for predictions.
        """
        if max_computes is not None:
            pulumi.set(__self__, "max_computes", max_computes)
        if min_computes is not None:
            pulumi.set(__self__, "min_computes", min_computes)
        if resource_bundle_id is not None:
            pulumi.set(__self__, "resource_bundle_id", resource_bundle_id)

    @property
    @pulumi.getter(name="maxComputes")
    def max_computes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of computes to use for predictions.
        """
        return pulumi.get(self, "max_computes")

    @max_computes.setter
    def max_computes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_computes", value)

    @property
    @pulumi.getter(name="minComputes")
    def min_computes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum number of computes to use for predictions.
        """
        return pulumi.get(self, "min_computes")

    @min_computes.setter
    def min_computes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_computes", value)

    @property
    @pulumi.getter(name="resourceBundleId")
    def resource_bundle_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource bundle ID to use for predictions.
        """
        return pulumi.get(self, "resource_bundle_id")

    @resource_bundle_id.setter
    def resource_bundle_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_bundle_id", value)


if not MYPY:
    class DeploymentRetrainingPolicyAutopilotOptionsArgsDict(TypedDict):
        blend_best_models: NotRequired[pulumi.Input[builtins.bool]]
        """
        Blend best models during Autopilot run. This option is not supported in SHAP-only mode.
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The autopiltot mode.
        """
        run_leakage_removed_feature_list: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run Autopilot on Leakage Removed feature list (if exists).
        """
        scoring_code_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        Keep only models that can be converted to scorable java code during Autopilot run.
        """
        shap_only_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Include only models with SHAP value support.
        """
elif False:
    DeploymentRetrainingPolicyAutopilotOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyAutopilotOptionsArgs:
    def __init__(__self__, *,
                 blend_best_models: Optional[pulumi.Input[builtins.bool]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 run_leakage_removed_feature_list: Optional[pulumi.Input[builtins.bool]] = None,
                 scoring_code_only: Optional[pulumi.Input[builtins.bool]] = None,
                 shap_only_mode: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] blend_best_models: Blend best models during Autopilot run. This option is not supported in SHAP-only mode.
        :param pulumi.Input[builtins.str] mode: The autopiltot mode.
        :param pulumi.Input[builtins.bool] run_leakage_removed_feature_list: Run Autopilot on Leakage Removed feature list (if exists).
        :param pulumi.Input[builtins.bool] scoring_code_only: Keep only models that can be converted to scorable java code during Autopilot run.
        :param pulumi.Input[builtins.bool] shap_only_mode: Include only models with SHAP value support.
        """
        if blend_best_models is not None:
            pulumi.set(__self__, "blend_best_models", blend_best_models)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if run_leakage_removed_feature_list is not None:
            pulumi.set(__self__, "run_leakage_removed_feature_list", run_leakage_removed_feature_list)
        if scoring_code_only is not None:
            pulumi.set(__self__, "scoring_code_only", scoring_code_only)
        if shap_only_mode is not None:
            pulumi.set(__self__, "shap_only_mode", shap_only_mode)

    @property
    @pulumi.getter(name="blendBestModels")
    def blend_best_models(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Blend best models during Autopilot run. This option is not supported in SHAP-only mode.
        """
        return pulumi.get(self, "blend_best_models")

    @blend_best_models.setter
    def blend_best_models(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "blend_best_models", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The autopiltot mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="runLeakageRemovedFeatureList")
    def run_leakage_removed_feature_list(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run Autopilot on Leakage Removed feature list (if exists).
        """
        return pulumi.get(self, "run_leakage_removed_feature_list")

    @run_leakage_removed_feature_list.setter
    def run_leakage_removed_feature_list(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "run_leakage_removed_feature_list", value)

    @property
    @pulumi.getter(name="scoringCodeOnly")
    def scoring_code_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Keep only models that can be converted to scorable java code during Autopilot run.
        """
        return pulumi.get(self, "scoring_code_only")

    @scoring_code_only.setter
    def scoring_code_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "scoring_code_only", value)

    @property
    @pulumi.getter(name="shapOnlyMode")
    def shap_only_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include only models with SHAP value support.
        """
        return pulumi.get(self, "shap_only_mode")

    @shap_only_mode.setter
    def shap_only_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "shap_only_mode", value)


if not MYPY:
    class DeploymentRetrainingPolicyProjectOptionsArgsDict(TypedDict):
        cv_method: NotRequired[pulumi.Input[builtins.str]]
        """
        The partitioning method for projects used to build new models.
        """
        holdout_pct: NotRequired[pulumi.Input[builtins.float]]
        """
        The percentage of dataset to assign to holdout set in projects used to build new models.
        """
        metric: NotRequired[pulumi.Input[builtins.str]]
        """
        The model selection metric in projects used to build new models.
        """
        reps: NotRequired[pulumi.Input[builtins.float]]
        """
        The number of cross validation folds to use for projects used to build new models.
        """
        validation_pct: NotRequired[pulumi.Input[builtins.float]]
        """
        The percentage of dataset to assign to validation set in projects used to build new models.
        """
        validation_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The validation type for projects used to build new models.
        """
elif False:
    DeploymentRetrainingPolicyProjectOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyProjectOptionsArgs:
    def __init__(__self__, *,
                 cv_method: Optional[pulumi.Input[builtins.str]] = None,
                 holdout_pct: Optional[pulumi.Input[builtins.float]] = None,
                 metric: Optional[pulumi.Input[builtins.str]] = None,
                 reps: Optional[pulumi.Input[builtins.float]] = None,
                 validation_pct: Optional[pulumi.Input[builtins.float]] = None,
                 validation_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cv_method: The partitioning method for projects used to build new models.
        :param pulumi.Input[builtins.float] holdout_pct: The percentage of dataset to assign to holdout set in projects used to build new models.
        :param pulumi.Input[builtins.str] metric: The model selection metric in projects used to build new models.
        :param pulumi.Input[builtins.float] reps: The number of cross validation folds to use for projects used to build new models.
        :param pulumi.Input[builtins.float] validation_pct: The percentage of dataset to assign to validation set in projects used to build new models.
        :param pulumi.Input[builtins.str] validation_type: The validation type for projects used to build new models.
        """
        if cv_method is not None:
            pulumi.set(__self__, "cv_method", cv_method)
        if holdout_pct is not None:
            pulumi.set(__self__, "holdout_pct", holdout_pct)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if reps is not None:
            pulumi.set(__self__, "reps", reps)
        if validation_pct is not None:
            pulumi.set(__self__, "validation_pct", validation_pct)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter(name="cvMethod")
    def cv_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The partitioning method for projects used to build new models.
        """
        return pulumi.get(self, "cv_method")

    @cv_method.setter
    def cv_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cv_method", value)

    @property
    @pulumi.getter(name="holdoutPct")
    def holdout_pct(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The percentage of dataset to assign to holdout set in projects used to build new models.
        """
        return pulumi.get(self, "holdout_pct")

    @holdout_pct.setter
    def holdout_pct(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "holdout_pct", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The model selection metric in projects used to build new models.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def reps(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The number of cross validation folds to use for projects used to build new models.
        """
        return pulumi.get(self, "reps")

    @reps.setter
    def reps(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "reps", value)

    @property
    @pulumi.getter(name="validationPct")
    def validation_pct(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The percentage of dataset to assign to validation set in projects used to build new models.
        """
        return pulumi.get(self, "validation_pct")

    @validation_pct.setter
    def validation_pct(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "validation_pct", value)

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The validation type for projects used to build new models.
        """
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validation_type", value)


if not MYPY:
    class DeploymentRetrainingPolicyTimeSeriesOptionsArgsDict(TypedDict):
        calendar_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the calendar to be used in this project.
        """
        differencing_method: NotRequired[pulumi.Input[builtins.str]]
        """
        For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems simple and seasonal are not allowed. Parameter periodicities must be specified if seasonal is chosen. Defaults to auto.
        """
        exponentially_weighted_moving_alpha: NotRequired[pulumi.Input[builtins.float]]
        """
        Discount factor (alpha) used for exponentially weighted moving features.
        """
        periodicities: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgsDict']]]]
        """
        A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter 'differencing*method' will default to 'seasonal' if not provided or 'auto'.
        """
        treat_as_exponential: NotRequired[pulumi.Input[builtins.str]]
        """
        For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems always is not allowed. Defaults to auto.
        """
elif False:
    DeploymentRetrainingPolicyTimeSeriesOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyTimeSeriesOptionsArgs:
    def __init__(__self__, *,
                 calendar_id: Optional[pulumi.Input[builtins.str]] = None,
                 differencing_method: Optional[pulumi.Input[builtins.str]] = None,
                 exponentially_weighted_moving_alpha: Optional[pulumi.Input[builtins.float]] = None,
                 periodicities: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs']]]] = None,
                 treat_as_exponential: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] calendar_id: The ID of the calendar to be used in this project.
        :param pulumi.Input[builtins.str] differencing_method: For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems simple and seasonal are not allowed. Parameter periodicities must be specified if seasonal is chosen. Defaults to auto.
        :param pulumi.Input[builtins.float] exponentially_weighted_moving_alpha: Discount factor (alpha) used for exponentially weighted moving features.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs']]] periodicities: A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter 'differencing*method' will default to 'seasonal' if not provided or 'auto'.
        :param pulumi.Input[builtins.str] treat_as_exponential: For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems always is not allowed. Defaults to auto.
        """
        if calendar_id is not None:
            pulumi.set(__self__, "calendar_id", calendar_id)
        if differencing_method is not None:
            pulumi.set(__self__, "differencing_method", differencing_method)
        if exponentially_weighted_moving_alpha is not None:
            pulumi.set(__self__, "exponentially_weighted_moving_alpha", exponentially_weighted_moving_alpha)
        if periodicities is not None:
            pulumi.set(__self__, "periodicities", periodicities)
        if treat_as_exponential is not None:
            pulumi.set(__self__, "treat_as_exponential", treat_as_exponential)

    @property
    @pulumi.getter(name="calendarId")
    def calendar_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the calendar to be used in this project.
        """
        return pulumi.get(self, "calendar_id")

    @calendar_id.setter
    def calendar_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "calendar_id", value)

    @property
    @pulumi.getter(name="differencingMethod")
    def differencing_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems simple and seasonal are not allowed. Parameter periodicities must be specified if seasonal is chosen. Defaults to auto.
        """
        return pulumi.get(self, "differencing_method")

    @differencing_method.setter
    def differencing_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "differencing_method", value)

    @property
    @pulumi.getter(name="exponentiallyWeightedMovingAlpha")
    def exponentially_weighted_moving_alpha(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Discount factor (alpha) used for exponentially weighted moving features.
        """
        return pulumi.get(self, "exponentially_weighted_moving_alpha")

    @exponentially_weighted_moving_alpha.setter
    def exponentially_weighted_moving_alpha(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "exponentially_weighted_moving_alpha", value)

    @property
    @pulumi.getter
    def periodicities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs']]]]:
        """
        A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter 'differencing*method' will default to 'seasonal' if not provided or 'auto'.
        """
        return pulumi.get(self, "periodicities")

    @periodicities.setter
    def periodicities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs']]]]):
        pulumi.set(self, "periodicities", value)

    @property
    @pulumi.getter(name="treatAsExponential")
    def treat_as_exponential(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems always is not allowed. Defaults to auto.
        """
        return pulumi.get(self, "treat_as_exponential")

    @treat_as_exponential.setter
    def treat_as_exponential(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "treat_as_exponential", value)


if not MYPY:
    class DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgsDict(TypedDict):
        time_steps: pulumi.Input[builtins.int]
        """
        The number of time steps.
        """
        time_unit: pulumi.Input[builtins.str]
        """
        The time unit or ROW if windowsBasisUnit is ROW
        """
elif False:
    DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyTimeSeriesOptionsPeriodicityArgs:
    def __init__(__self__, *,
                 time_steps: pulumi.Input[builtins.int],
                 time_unit: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] time_steps: The number of time steps.
        :param pulumi.Input[builtins.str] time_unit: The time unit or ROW if windowsBasisUnit is ROW
        """
        pulumi.set(__self__, "time_steps", time_steps)
        pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeSteps")
    def time_steps(self) -> pulumi.Input[builtins.int]:
        """
        The number of time steps.
        """
        return pulumi.get(self, "time_steps")

    @time_steps.setter
    def time_steps(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "time_steps", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> pulumi.Input[builtins.str]:
        """
        The time unit or ROW if windowsBasisUnit is ROW
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class DeploymentRetrainingPolicyTriggerArgsDict(TypedDict):
        custom_job_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom job ID for the retraining policy.
        """
        min_interval_between_runs: NotRequired[pulumi.Input[builtins.str]]
        """
        Minimal interval between policy runs in ISO 8601 duration string.
        """
        schedule: NotRequired[pulumi.Input['DeploymentRetrainingPolicyTriggerScheduleArgsDict']]
        """
        Schedule for the retraining policy.
        """
        status_declines_to_failing: NotRequired[pulumi.Input[builtins.bool]]
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to failing.
        """
        status_declines_to_warning: NotRequired[pulumi.Input[builtins.bool]]
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to warning.
        """
        status_still_in_decline: NotRequired[pulumi.Input[builtins.bool]]
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status still in decline.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of retraining policy trigger.
        """
elif False:
    DeploymentRetrainingPolicyTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyTriggerArgs:
    def __init__(__self__, *,
                 custom_job_id: Optional[pulumi.Input[builtins.str]] = None,
                 min_interval_between_runs: Optional[pulumi.Input[builtins.str]] = None,
                 schedule: Optional[pulumi.Input['DeploymentRetrainingPolicyTriggerScheduleArgs']] = None,
                 status_declines_to_failing: Optional[pulumi.Input[builtins.bool]] = None,
                 status_declines_to_warning: Optional[pulumi.Input[builtins.bool]] = None,
                 status_still_in_decline: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] custom_job_id: Custom job ID for the retraining policy.
        :param pulumi.Input[builtins.str] min_interval_between_runs: Minimal interval between policy runs in ISO 8601 duration string.
        :param pulumi.Input['DeploymentRetrainingPolicyTriggerScheduleArgs'] schedule: Schedule for the retraining policy.
        :param pulumi.Input[builtins.bool] status_declines_to_failing: Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to failing.
        :param pulumi.Input[builtins.bool] status_declines_to_warning: Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to warning.
        :param pulumi.Input[builtins.bool] status_still_in_decline: Identifies when trigger type is based on deployment a health status, whether the policy will run when health status still in decline.
        :param pulumi.Input[builtins.str] type: Type of retraining policy trigger.
        """
        if custom_job_id is not None:
            pulumi.set(__self__, "custom_job_id", custom_job_id)
        if min_interval_between_runs is not None:
            pulumi.set(__self__, "min_interval_between_runs", min_interval_between_runs)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if status_declines_to_failing is not None:
            pulumi.set(__self__, "status_declines_to_failing", status_declines_to_failing)
        if status_declines_to_warning is not None:
            pulumi.set(__self__, "status_declines_to_warning", status_declines_to_warning)
        if status_still_in_decline is not None:
            pulumi.set(__self__, "status_still_in_decline", status_still_in_decline)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="customJobId")
    def custom_job_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom job ID for the retraining policy.
        """
        return pulumi.get(self, "custom_job_id")

    @custom_job_id.setter
    def custom_job_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_job_id", value)

    @property
    @pulumi.getter(name="minIntervalBetweenRuns")
    def min_interval_between_runs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Minimal interval between policy runs in ISO 8601 duration string.
        """
        return pulumi.get(self, "min_interval_between_runs")

    @min_interval_between_runs.setter
    def min_interval_between_runs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_interval_between_runs", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['DeploymentRetrainingPolicyTriggerScheduleArgs']]:
        """
        Schedule for the retraining policy.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['DeploymentRetrainingPolicyTriggerScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="statusDeclinesToFailing")
    def status_declines_to_failing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to failing.
        """
        return pulumi.get(self, "status_declines_to_failing")

    @status_declines_to_failing.setter
    def status_declines_to_failing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status_declines_to_failing", value)

    @property
    @pulumi.getter(name="statusDeclinesToWarning")
    def status_declines_to_warning(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status declines to warning.
        """
        return pulumi.get(self, "status_declines_to_warning")

    @status_declines_to_warning.setter
    def status_declines_to_warning(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status_declines_to_warning", value)

    @property
    @pulumi.getter(name="statusStillInDecline")
    def status_still_in_decline(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Identifies when trigger type is based on deployment a health status, whether the policy will run when health status still in decline.
        """
        return pulumi.get(self, "status_still_in_decline")

    @status_still_in_decline.setter
    def status_still_in_decline(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status_still_in_decline", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of retraining policy trigger.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentRetrainingPolicyTriggerScheduleArgsDict(TypedDict):
        day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the month when the job will run.
        """
        day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Days of the week when the job will run.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Hours of the day when the job will run.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Minutes of the day when the job will run.
        """
        months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Months of the year when the job will run.
        """
elif False:
    DeploymentRetrainingPolicyTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingPolicyTriggerScheduleArgs:
    def __init__(__self__, *,
                 day_of_months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 day_of_weeks: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 months: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_months: Days of the month when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] day_of_weeks: Days of the week when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hours: Hours of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] minutes: Minutes of the day when the job will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Months of the year when the job will run.
        """
        pulumi.set(__self__, "day_of_months", day_of_months)
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "months", months)

    @property
    @pulumi.getter(name="dayOfMonths")
    def day_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the month when the job will run.
        """
        return pulumi.get(self, "day_of_months")

    @day_of_months.setter
    def day_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_months", value)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Days of the week when the job will run.
        """
        return pulumi.get(self, "day_of_weeks")

    @day_of_weeks.setter
    def day_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "day_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Hours of the day when the job will run.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Minutes of the day when the job will run.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def months(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Months of the year when the job will run.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "months", value)


if not MYPY:
    class DeploymentRetrainingSettingsArgsDict(TypedDict):
        credential_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the credential used to refresh retraining dataset.
        """
        dataset_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the retraining dataset.
        """
        prediction_environment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the prediction environment to associate with the challengers created by retraining policies.
        """
        retraining_user_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the retraining user.
        """
elif False:
    DeploymentRetrainingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRetrainingSettingsArgs:
    def __init__(__self__, *,
                 credential_id: Optional[pulumi.Input[builtins.str]] = None,
                 dataset_id: Optional[pulumi.Input[builtins.str]] = None,
                 prediction_environment_id: Optional[pulumi.Input[builtins.str]] = None,
                 retraining_user_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] credential_id: ID of the credential used to refresh retraining dataset.
        :param pulumi.Input[builtins.str] dataset_id: ID of the retraining dataset.
        :param pulumi.Input[builtins.str] prediction_environment_id: ID of the prediction environment to associate with the challengers created by retraining policies.
        :param pulumi.Input[builtins.str] retraining_user_id: ID of the retraining user.
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if prediction_environment_id is not None:
            pulumi.set(__self__, "prediction_environment_id", prediction_environment_id)
        if retraining_user_id is not None:
            pulumi.set(__self__, "retraining_user_id", retraining_user_id)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the credential used to refresh retraining dataset.
        """
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the retraining dataset.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="predictionEnvironmentId")
    def prediction_environment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the prediction environment to associate with the challengers created by retraining policies.
        """
        return pulumi.get(self, "prediction_environment_id")

    @prediction_environment_id.setter
    def prediction_environment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prediction_environment_id", value)

    @property
    @pulumi.getter(name="retrainingUserId")
    def retraining_user_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the retraining user.
        """
        return pulumi.get(self, "retraining_user_id")

    @retraining_user_id.setter
    def retraining_user_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "retraining_user_id", value)


if not MYPY:
    class DeploymentRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    DeploymentRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The name of the runtime parameter.
        :param pulumi.Input[builtins.str] type: The type of the runtime parameter.
        :param pulumi.Input[builtins.str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentSegmentAnalysisSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Set to 'True' if segment analysis is enabled for this deployment.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of strings that gives the segment attributes selected for tracking.
        """
elif False:
    DeploymentSegmentAnalysisSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSegmentAnalysisSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Set to 'True' if segment analysis is enabled for this deployment.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] attributes: A list of strings that gives the segment attributes selected for tracking.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Set to 'True' if segment analysis is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of strings that gives the segment attributes selected for tracking.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class LlmBlueprintCustomModelLlmSettingsArgsDict(TypedDict):
        external_llm_context_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The external LLM's context size, in tokens. This value is only used for pruning documents supplied to the LLM when a vector database is associated with the LLM blueprint. It does not affect the external LLM's actual context size in any way and is not supplied to the LLM.
        """
        system_prompt: NotRequired[pulumi.Input[builtins.str]]
        """
        System prompt guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        validation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The validation ID of the custom model LLM.
        """
elif False:
    LlmBlueprintCustomModelLlmSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LlmBlueprintCustomModelLlmSettingsArgs:
    def __init__(__self__, *,
                 external_llm_context_size: Optional[pulumi.Input[builtins.int]] = None,
                 system_prompt: Optional[pulumi.Input[builtins.str]] = None,
                 validation_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] external_llm_context_size: The external LLM's context size, in tokens. This value is only used for pruning documents supplied to the LLM when a vector database is associated with the LLM blueprint. It does not affect the external LLM's actual context size in any way and is not supplied to the LLM.
        :param pulumi.Input[builtins.str] system_prompt: System prompt guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        :param pulumi.Input[builtins.str] validation_id: The validation ID of the custom model LLM.
        """
        if external_llm_context_size is not None:
            pulumi.set(__self__, "external_llm_context_size", external_llm_context_size)
        if system_prompt is not None:
            pulumi.set(__self__, "system_prompt", system_prompt)
        if validation_id is not None:
            pulumi.set(__self__, "validation_id", validation_id)

    @property
    @pulumi.getter(name="externalLlmContextSize")
    def external_llm_context_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The external LLM's context size, in tokens. This value is only used for pruning documents supplied to the LLM when a vector database is associated with the LLM blueprint. It does not affect the external LLM's actual context size in any way and is not supplied to the LLM.
        """
        return pulumi.get(self, "external_llm_context_size")

    @external_llm_context_size.setter
    def external_llm_context_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "external_llm_context_size", value)

    @property
    @pulumi.getter(name="systemPrompt")
    def system_prompt(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        System prompt guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        return pulumi.get(self, "system_prompt")

    @system_prompt.setter
    def system_prompt(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_prompt", value)

    @property
    @pulumi.getter(name="validationId")
    def validation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The validation ID of the custom model LLM.
        """
        return pulumi.get(self, "validation_id")

    @validation_id.setter
    def validation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validation_id", value)


if not MYPY:
    class LlmBlueprintLlmSettingsArgsDict(TypedDict):
        max_completion_length: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        """
        system_prompt: NotRequired[pulumi.Input[builtins.str]]
        """
        Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        temperature: NotRequired[pulumi.Input[builtins.float]]
        """
        Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        """
        top_p: NotRequired[pulumi.Input[builtins.float]]
        """
        Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
elif False:
    LlmBlueprintLlmSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LlmBlueprintLlmSettingsArgs:
    def __init__(__self__, *,
                 max_completion_length: Optional[pulumi.Input[builtins.int]] = None,
                 system_prompt: Optional[pulumi.Input[builtins.str]] = None,
                 temperature: Optional[pulumi.Input[builtins.float]] = None,
                 top_p: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.int] max_completion_length: The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        :param pulumi.Input[builtins.str] system_prompt: Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        :param pulumi.Input[builtins.float] temperature: Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        :param pulumi.Input[builtins.float] top_p: Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        if max_completion_length is not None:
            pulumi.set(__self__, "max_completion_length", max_completion_length)
        if system_prompt is not None:
            pulumi.set(__self__, "system_prompt", system_prompt)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxCompletionLength")
    def max_completion_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        """
        return pulumi.get(self, "max_completion_length")

    @max_completion_length.setter
    def max_completion_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_completion_length", value)

    @property
    @pulumi.getter(name="systemPrompt")
    def system_prompt(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        return pulumi.get(self, "system_prompt")

    @system_prompt.setter
    def system_prompt(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_prompt", value)

    @property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class LlmBlueprintVectorDatabaseSettingsArgsDict(TypedDict):
        max_documents_retrieved_per_prompt: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of documents to retrieve from the Vector Database.
        """
        max_tokens: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of tokens to retrieve from the Vector Database.
        """
elif False:
    LlmBlueprintVectorDatabaseSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LlmBlueprintVectorDatabaseSettingsArgs:
    def __init__(__self__, *,
                 max_documents_retrieved_per_prompt: Optional[pulumi.Input[builtins.int]] = None,
                 max_tokens: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_documents_retrieved_per_prompt: The maximum number of documents to retrieve from the Vector Database.
        :param pulumi.Input[builtins.int] max_tokens: The maximum number of tokens to retrieve from the Vector Database.
        """
        if max_documents_retrieved_per_prompt is not None:
            pulumi.set(__self__, "max_documents_retrieved_per_prompt", max_documents_retrieved_per_prompt)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxDocumentsRetrievedPerPrompt")
    def max_documents_retrieved_per_prompt(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of documents to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_documents_retrieved_per_prompt")

    @max_documents_retrieved_per_prompt.setter
    def max_documents_retrieved_per_prompt(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_documents_retrieved_per_prompt", value)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of tokens to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class NotificationChannelCustomHeaderArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the header.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the header.
        """
elif False:
    NotificationChannelCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationChannelCustomHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: The name of the header.
        :param pulumi.Input[builtins.str] value: The value of the header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationChannelDrEntityArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The ID of the DataRobot entity.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the entity.
        """
elif False:
    NotificationChannelDrEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationChannelDrEntityArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] id: The ID of the DataRobot entity.
        :param pulumi.Input[builtins.str] name: The name of the entity.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the DataRobot entity.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the entity.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VectorDatabaseChunkingParametersArgsDict(TypedDict):
        chunk_overlap_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        The percentage of overlap between chunks.
        """
        chunk_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The size of the chunks.
        """
        chunking_method: NotRequired[pulumi.Input[builtins.str]]
        """
        The method used to chunk the data.
        """
        embedding_model: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the Embedding Model.
        """
        is_separator_regex: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the separator is a regex.
        """
        separators: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The separators used to split the data.
        """
elif False:
    VectorDatabaseChunkingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorDatabaseChunkingParametersArgs:
    def __init__(__self__, *,
                 chunk_overlap_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 chunk_size: Optional[pulumi.Input[builtins.int]] = None,
                 chunking_method: Optional[pulumi.Input[builtins.str]] = None,
                 embedding_model: Optional[pulumi.Input[builtins.str]] = None,
                 is_separator_regex: Optional[pulumi.Input[builtins.bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.int] chunk_overlap_percentage: The percentage of overlap between chunks.
        :param pulumi.Input[builtins.int] chunk_size: The size of the chunks.
        :param pulumi.Input[builtins.str] chunking_method: The method used to chunk the data.
        :param pulumi.Input[builtins.str] embedding_model: The id of the Embedding Model.
        :param pulumi.Input[builtins.bool] is_separator_regex: Whether the separator is a regex.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] separators: The separators used to split the data.
        """
        if chunk_overlap_percentage is not None:
            pulumi.set(__self__, "chunk_overlap_percentage", chunk_overlap_percentage)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if chunking_method is not None:
            pulumi.set(__self__, "chunking_method", chunking_method)
        if embedding_model is not None:
            pulumi.set(__self__, "embedding_model", embedding_model)
        if is_separator_regex is not None:
            pulumi.set(__self__, "is_separator_regex", is_separator_regex)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="chunkOverlapPercentage")
    def chunk_overlap_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The percentage of overlap between chunks.
        """
        return pulumi.get(self, "chunk_overlap_percentage")

    @chunk_overlap_percentage.setter
    def chunk_overlap_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "chunk_overlap_percentage", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size of the chunks.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkingMethod")
    def chunking_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The method used to chunk the data.
        """
        return pulumi.get(self, "chunking_method")

    @chunking_method.setter
    def chunking_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "chunking_method", value)

    @property
    @pulumi.getter(name="embeddingModel")
    def embedding_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the Embedding Model.
        """
        return pulumi.get(self, "embedding_model")

    @embedding_model.setter
    def embedding_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "embedding_model", value)

    @property
    @pulumi.getter(name="isSeparatorRegex")
    def is_separator_regex(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the separator is a regex.
        """
        return pulumi.get(self, "is_separator_regex")

    @is_separator_regex.setter
    def is_separator_regex(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_separator_regex", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The separators used to split the data.
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "separators", value)


