# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApplicationSourceResourceSettingsArgs',
    'ApplicationSourceResourceSettingsArgsDict',
    'ApplicationSourceRuntimeParameterValueArgs',
    'ApplicationSourceRuntimeParameterValueArgsDict',
    'CustomModelGuardConfigurationArgs',
    'CustomModelGuardConfigurationArgsDict',
    'CustomModelGuardConfigurationInterventionArgs',
    'CustomModelGuardConfigurationInterventionArgsDict',
    'CustomModelOverallModerationConfigurationArgs',
    'CustomModelOverallModerationConfigurationArgsDict',
    'CustomModelResourceSettingsArgs',
    'CustomModelResourceSettingsArgsDict',
    'CustomModelRuntimeParameterValueArgs',
    'CustomModelRuntimeParameterValueArgsDict',
    'CustomModelSourceRemoteRepositoryArgs',
    'CustomModelSourceRemoteRepositoryArgsDict',
    'DeploymentAssociationIdSettingsArgs',
    'DeploymentAssociationIdSettingsArgsDict',
    'DeploymentBiasAndFairnessSettingsArgs',
    'DeploymentBiasAndFairnessSettingsArgsDict',
    'DeploymentChallengerModelsSettingsArgs',
    'DeploymentChallengerModelsSettingsArgsDict',
    'DeploymentChallengerReplaySettingsArgs',
    'DeploymentChallengerReplaySettingsArgsDict',
    'DeploymentDriftTrackingSettingsArgs',
    'DeploymentDriftTrackingSettingsArgsDict',
    'DeploymentHealthSettingsArgs',
    'DeploymentHealthSettingsArgsDict',
    'DeploymentHealthSettingsAccuracyArgs',
    'DeploymentHealthSettingsAccuracyArgsDict',
    'DeploymentHealthSettingsActualsTimelinessArgs',
    'DeploymentHealthSettingsActualsTimelinessArgsDict',
    'DeploymentHealthSettingsCustomMetricsArgs',
    'DeploymentHealthSettingsCustomMetricsArgsDict',
    'DeploymentHealthSettingsCustomMetricsFailingConditionArgs',
    'DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict',
    'DeploymentHealthSettingsCustomMetricsWarningConditionArgs',
    'DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict',
    'DeploymentHealthSettingsDataDriftArgs',
    'DeploymentHealthSettingsDataDriftArgsDict',
    'DeploymentHealthSettingsFairnessArgs',
    'DeploymentHealthSettingsFairnessArgsDict',
    'DeploymentHealthSettingsPredictionsTimelinessArgs',
    'DeploymentHealthSettingsPredictionsTimelinessArgsDict',
    'DeploymentHealthSettingsServiceArgs',
    'DeploymentHealthSettingsServiceArgsDict',
    'DeploymentPredictionIntervalsSettingsArgs',
    'DeploymentPredictionIntervalsSettingsArgsDict',
    'DeploymentPredictionWarningSettingsArgs',
    'DeploymentPredictionWarningSettingsArgsDict',
    'DeploymentPredictionWarningSettingsCustomBoundariesArgs',
    'DeploymentPredictionWarningSettingsCustomBoundariesArgsDict',
    'DeploymentPredictionsByForecastDateSettingsArgs',
    'DeploymentPredictionsByForecastDateSettingsArgsDict',
    'DeploymentPredictionsDataCollectionSettingsArgs',
    'DeploymentPredictionsDataCollectionSettingsArgsDict',
    'DeploymentPredictionsSettingsArgs',
    'DeploymentPredictionsSettingsArgsDict',
    'DeploymentSegmentAnalysisSettingsArgs',
    'DeploymentSegmentAnalysisSettingsArgsDict',
    'LlmBlueprintLlmSettingsArgs',
    'LlmBlueprintLlmSettingsArgsDict',
    'LlmBlueprintVectorDatabaseSettingsArgs',
    'LlmBlueprintVectorDatabaseSettingsArgsDict',
    'VectorDatabaseChunkingParametersArgs',
    'VectorDatabaseChunkingParametersArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationSourceResourceSettingsArgsDict(TypedDict):
        replicas: NotRequired[pulumi.Input[int]]
        """
        The replicas for the Application Source.
        """
elif False:
    ApplicationSourceResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceResourceSettingsArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] replicas: The replicas for the Application Source.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The replicas for the Application Source.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class ApplicationSourceRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    ApplicationSourceRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSourceRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The name of the runtime parameter.
        :param pulumi.Input[str] type: The type of the runtime parameter.
        :param pulumi.Input[str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomModelGuardConfigurationArgsDict(TypedDict):
        intervention: pulumi.Input['CustomModelGuardConfigurationInterventionArgsDict']
        """
        The intervention for the guard configuration.
        """
        name: pulumi.Input[str]
        """
        The name of the guard configuration.
        """
        stages: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of stages for the guard configuration.
        """
        template_name: pulumi.Input[str]
        """
        The template name of the guard configuration.
        """
        deployment_id: NotRequired[pulumi.Input[str]]
        """
        The deployment ID of this guard.
        """
        input_column_name: NotRequired[pulumi.Input[str]]
        """
        The input column name of this guard.
        """
        llm_type: NotRequired[pulumi.Input[str]]
        """
        The LLM type for this guard.
        """
        openai_api_base: NotRequired[pulumi.Input[str]]
        """
        The OpenAI API base URL for this guard.
        """
        openai_credential: NotRequired[pulumi.Input[str]]
        """
        The ID of an OpenAI credential for this guard.
        """
        openai_deployment_id: NotRequired[pulumi.Input[str]]
        """
        The ID of an OpenAI deployment for this guard.
        """
        output_column_name: NotRequired[pulumi.Input[str]]
        """
        The output column name of this guard.
        """
elif False:
    CustomModelGuardConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelGuardConfigurationArgs:
    def __init__(__self__, *,
                 intervention: pulumi.Input['CustomModelGuardConfigurationInterventionArgs'],
                 name: pulumi.Input[str],
                 stages: pulumi.Input[Sequence[pulumi.Input[str]]],
                 template_name: pulumi.Input[str],
                 deployment_id: Optional[pulumi.Input[str]] = None,
                 input_column_name: Optional[pulumi.Input[str]] = None,
                 llm_type: Optional[pulumi.Input[str]] = None,
                 openai_api_base: Optional[pulumi.Input[str]] = None,
                 openai_credential: Optional[pulumi.Input[str]] = None,
                 openai_deployment_id: Optional[pulumi.Input[str]] = None,
                 output_column_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CustomModelGuardConfigurationInterventionArgs'] intervention: The intervention for the guard configuration.
        :param pulumi.Input[str] name: The name of the guard configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stages: The list of stages for the guard configuration.
        :param pulumi.Input[str] template_name: The template name of the guard configuration.
        :param pulumi.Input[str] deployment_id: The deployment ID of this guard.
        :param pulumi.Input[str] input_column_name: The input column name of this guard.
        :param pulumi.Input[str] llm_type: The LLM type for this guard.
        :param pulumi.Input[str] openai_api_base: The OpenAI API base URL for this guard.
        :param pulumi.Input[str] openai_credential: The ID of an OpenAI credential for this guard.
        :param pulumi.Input[str] openai_deployment_id: The ID of an OpenAI deployment for this guard.
        :param pulumi.Input[str] output_column_name: The output column name of this guard.
        """
        pulumi.set(__self__, "intervention", intervention)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "template_name", template_name)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if input_column_name is not None:
            pulumi.set(__self__, "input_column_name", input_column_name)
        if llm_type is not None:
            pulumi.set(__self__, "llm_type", llm_type)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_credential is not None:
            pulumi.set(__self__, "openai_credential", openai_credential)
        if openai_deployment_id is not None:
            pulumi.set(__self__, "openai_deployment_id", openai_deployment_id)
        if output_column_name is not None:
            pulumi.set(__self__, "output_column_name", output_column_name)

    @property
    @pulumi.getter
    def intervention(self) -> pulumi.Input['CustomModelGuardConfigurationInterventionArgs']:
        """
        The intervention for the guard configuration.
        """
        return pulumi.get(self, "intervention")

    @intervention.setter
    def intervention(self, value: pulumi.Input['CustomModelGuardConfigurationInterventionArgs']):
        pulumi.set(self, "intervention", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the guard configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of stages for the guard configuration.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stages", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[str]:
        """
        The template name of the guard configuration.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_name", value)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The deployment ID of this guard.
        """
        return pulumi.get(self, "deployment_id")

    @deployment_id.setter
    def deployment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_id", value)

    @property
    @pulumi.getter(name="inputColumnName")
    def input_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The input column name of this guard.
        """
        return pulumi.get(self, "input_column_name")

    @input_column_name.setter
    def input_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_column_name", value)

    @property
    @pulumi.getter(name="llmType")
    def llm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The LLM type for this guard.
        """
        return pulumi.get(self, "llm_type")

    @llm_type.setter
    def llm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "llm_type", value)

    @property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenAI API base URL for this guard.
        """
        return pulumi.get(self, "openai_api_base")

    @openai_api_base.setter
    def openai_api_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_base", value)

    @property
    @pulumi.getter(name="openaiCredential")
    def openai_credential(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an OpenAI credential for this guard.
        """
        return pulumi.get(self, "openai_credential")

    @openai_credential.setter
    def openai_credential(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_credential", value)

    @property
    @pulumi.getter(name="openaiDeploymentId")
    def openai_deployment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an OpenAI deployment for this guard.
        """
        return pulumi.get(self, "openai_deployment_id")

    @openai_deployment_id.setter
    def openai_deployment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_deployment_id", value)

    @property
    @pulumi.getter(name="outputColumnName")
    def output_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The output column name of this guard.
        """
        return pulumi.get(self, "output_column_name")

    @output_column_name.setter
    def output_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_column_name", value)


if not MYPY:
    class CustomModelGuardConfigurationInterventionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action of the guard intervention.
        """
        condition: pulumi.Input[str]
        """
        The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The message of the guard intervention.
        """
elif False:
    CustomModelGuardConfigurationInterventionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelGuardConfigurationInterventionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 condition: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action of the guard intervention.
        :param pulumi.Input[str] condition: The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        :param pulumi.Input[str] message: The message of the guard intervention.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action of the guard intervention.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        The JSON-encoded condition of the guard intervention. e.g. `{"comparand": 0.5, "comparator": "lessThan"}`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The message of the guard intervention.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CustomModelOverallModerationConfigurationArgsDict(TypedDict):
        timeout_action: NotRequired[pulumi.Input[str]]
        """
        The timeout action of the overall moderation configuration.
        """
        timeout_sec: NotRequired[pulumi.Input[int]]
        """
        The timeout in seconds of the overall moderation configuration.
        """
elif False:
    CustomModelOverallModerationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOverallModerationConfigurationArgs:
    def __init__(__self__, *,
                 timeout_action: Optional[pulumi.Input[str]] = None,
                 timeout_sec: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] timeout_action: The timeout action of the overall moderation configuration.
        :param pulumi.Input[int] timeout_sec: The timeout in seconds of the overall moderation configuration.
        """
        if timeout_action is not None:
            pulumi.set(__self__, "timeout_action", timeout_action)
        if timeout_sec is not None:
            pulumi.set(__self__, "timeout_sec", timeout_sec)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout action of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_action", value)

    @property
    @pulumi.getter(name="timeoutSec")
    def timeout_sec(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout in seconds of the overall moderation configuration.
        """
        return pulumi.get(self, "timeout_sec")

    @timeout_sec.setter
    def timeout_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_sec", value)


if not MYPY:
    class CustomModelResourceSettingsArgsDict(TypedDict):
        memory_mb: NotRequired[pulumi.Input[int]]
        """
        The memory in MB for the Custom Model.
        """
        network_access: NotRequired[pulumi.Input[str]]
        """
        The network access for the Custom Model.
        """
        replicas: NotRequired[pulumi.Input[int]]
        """
        The replicas for the Custom Model.
        """
elif False:
    CustomModelResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelResourceSettingsArgs:
    def __init__(__self__, *,
                 memory_mb: Optional[pulumi.Input[int]] = None,
                 network_access: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] memory_mb: The memory in MB for the Custom Model.
        :param pulumi.Input[str] network_access: The network access for the Custom Model.
        :param pulumi.Input[int] replicas: The replicas for the Custom Model.
        """
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if network_access is not None:
            pulumi.set(__self__, "network_access", network_access)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The memory in MB for the Custom Model.
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter(name="networkAccess")
    def network_access(self) -> Optional[pulumi.Input[str]]:
        """
        The network access for the Custom Model.
        """
        return pulumi.get(self, "network_access")

    @network_access.setter
    def network_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_access", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The replicas for the Custom Model.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class CustomModelRuntimeParameterValueArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The name of the runtime parameter.
        """
        type: pulumi.Input[str]
        """
        The type of the runtime parameter.
        """
        value: pulumi.Input[str]
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
elif False:
    CustomModelRuntimeParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelRuntimeParameterValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The name of the runtime parameter.
        :param pulumi.Input[str] type: The type of the runtime parameter.
        :param pulumi.Input[str] value: The value of the runtime parameter (type conversion is handled internally).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the runtime parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the runtime parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the runtime parameter (type conversion is handled internally).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomModelSourceRemoteRepositoryArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the source remote repository.
        """
        ref: pulumi.Input[str]
        """
        The reference of the source remote repository.
        """
        source_paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of source paths in the source remote repository.
        """
elif False:
    CustomModelSourceRemoteRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelSourceRemoteRepositoryArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 ref: pulumi.Input[str],
                 source_paths: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] id: The ID of the source remote repository.
        :param pulumi.Input[str] ref: The reference of the source remote repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_paths: The list of source paths in the source remote repository.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "source_paths", source_paths)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the source remote repository.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input[str]:
        """
        The reference of the source remote repository.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "ref", value)

    @property
    @pulumi.getter(name="sourcePaths")
    def source_paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of source paths in the source remote repository.
        """
        return pulumi.get(self, "source_paths")

    @source_paths.setter
    def source_paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "source_paths", value)


if not MYPY:
    class DeploymentAssociationIdSettingsArgsDict(TypedDict):
        auto_generate_id: NotRequired[pulumi.Input[bool]]
        """
        Whether to auto generate ID.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Name of the columns to be used as association ID, currently only support a list of one string.
        """
        required_in_prediction_requests: NotRequired[pulumi.Input[bool]]
        """
        Whether the association ID column is required in prediction requests.
        """
elif False:
    DeploymentAssociationIdSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentAssociationIdSettingsArgs:
    def __init__(__self__, *,
                 auto_generate_id: Optional[pulumi.Input[bool]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required_in_prediction_requests: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_generate_id: Whether to auto generate ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: Name of the columns to be used as association ID, currently only support a list of one string.
        :param pulumi.Input[bool] required_in_prediction_requests: Whether the association ID column is required in prediction requests.
        """
        if auto_generate_id is not None:
            pulumi.set(__self__, "auto_generate_id", auto_generate_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if required_in_prediction_requests is not None:
            pulumi.set(__self__, "required_in_prediction_requests", required_in_prediction_requests)

    @property
    @pulumi.getter(name="autoGenerateId")
    def auto_generate_id(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to auto generate ID.
        """
        return pulumi.get(self, "auto_generate_id")

    @auto_generate_id.setter
    def auto_generate_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_generate_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Name of the columns to be used as association ID, currently only support a list of one string.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="requiredInPredictionRequests")
    def required_in_prediction_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the association ID column is required in prediction requests.
        """
        return pulumi.get(self, "required_in_prediction_requests")

    @required_in_prediction_requests.setter
    def required_in_prediction_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_in_prediction_requests", value)


if not MYPY:
    class DeploymentBiasAndFairnessSettingsArgsDict(TypedDict):
        fairness_metric_set: pulumi.Input[str]
        """
        A set of fairness metrics to use for calculating fairness.
        """
        fairness_threshold: pulumi.Input[float]
        """
        Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        """
        preferable_target_value: pulumi.Input[bool]
        """
        A target value that should be treated as a positive outcome for the prediction.
        """
        protected_features: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of features to mark as protected.
        """
elif False:
    DeploymentBiasAndFairnessSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentBiasAndFairnessSettingsArgs:
    def __init__(__self__, *,
                 fairness_metric_set: pulumi.Input[str],
                 fairness_threshold: pulumi.Input[float],
                 preferable_target_value: pulumi.Input[bool],
                 protected_features: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] fairness_metric_set: A set of fairness metrics to use for calculating fairness.
        :param pulumi.Input[float] fairness_threshold: Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        :param pulumi.Input[bool] preferable_target_value: A target value that should be treated as a positive outcome for the prediction.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protected_features: A list of features to mark as protected.
        """
        pulumi.set(__self__, "fairness_metric_set", fairness_metric_set)
        pulumi.set(__self__, "fairness_threshold", fairness_threshold)
        pulumi.set(__self__, "preferable_target_value", preferable_target_value)
        pulumi.set(__self__, "protected_features", protected_features)

    @property
    @pulumi.getter(name="fairnessMetricSet")
    def fairness_metric_set(self) -> pulumi.Input[str]:
        """
        A set of fairness metrics to use for calculating fairness.
        """
        return pulumi.get(self, "fairness_metric_set")

    @fairness_metric_set.setter
    def fairness_metric_set(self, value: pulumi.Input[str]):
        pulumi.set(self, "fairness_metric_set", value)

    @property
    @pulumi.getter(name="fairnessThreshold")
    def fairness_threshold(self) -> pulumi.Input[float]:
        """
        Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.
        """
        return pulumi.get(self, "fairness_threshold")

    @fairness_threshold.setter
    def fairness_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "fairness_threshold", value)

    @property
    @pulumi.getter(name="preferableTargetValue")
    def preferable_target_value(self) -> pulumi.Input[bool]:
        """
        A target value that should be treated as a positive outcome for the prediction.
        """
        return pulumi.get(self, "preferable_target_value")

    @preferable_target_value.setter
    def preferable_target_value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "preferable_target_value", value)

    @property
    @pulumi.getter(name="protectedFeatures")
    def protected_features(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of features to mark as protected.
        """
        return pulumi.get(self, "protected_features")

    @protected_features.setter
    def protected_features(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "protected_features", value)


if not MYPY:
    class DeploymentChallengerModelsSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is 'True' if challenger models is enabled for this deployment.
        """
elif False:
    DeploymentChallengerModelsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChallengerModelsSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Is 'True' if challenger models is enabled for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is 'True' if challenger models is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentChallengerReplaySettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If challenger replay is enabled.
        """
elif False:
    DeploymentChallengerReplaySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChallengerReplaySettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: If challenger replay is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If challenger replay is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentDriftTrackingSettingsArgsDict(TypedDict):
        feature_drift_enabled: NotRequired[pulumi.Input[bool]]
        """
        If feature drift tracking is to be turned on.
        """
        target_drift_enabled: NotRequired[pulumi.Input[bool]]
        """
        If target drift tracking is to be turned on.
        """
elif False:
    DeploymentDriftTrackingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDriftTrackingSettingsArgs:
    def __init__(__self__, *,
                 feature_drift_enabled: Optional[pulumi.Input[bool]] = None,
                 target_drift_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] feature_drift_enabled: If feature drift tracking is to be turned on.
        :param pulumi.Input[bool] target_drift_enabled: If target drift tracking is to be turned on.
        """
        if feature_drift_enabled is not None:
            pulumi.set(__self__, "feature_drift_enabled", feature_drift_enabled)
        if target_drift_enabled is not None:
            pulumi.set(__self__, "target_drift_enabled", target_drift_enabled)

    @property
    @pulumi.getter(name="featureDriftEnabled")
    def feature_drift_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If feature drift tracking is to be turned on.
        """
        return pulumi.get(self, "feature_drift_enabled")

    @feature_drift_enabled.setter
    def feature_drift_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "feature_drift_enabled", value)

    @property
    @pulumi.getter(name="targetDriftEnabled")
    def target_drift_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If target drift tracking is to be turned on.
        """
        return pulumi.get(self, "target_drift_enabled")

    @target_drift_enabled.setter
    def target_drift_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "target_drift_enabled", value)


if not MYPY:
    class DeploymentHealthSettingsArgsDict(TypedDict):
        accuracy: NotRequired[pulumi.Input['DeploymentHealthSettingsAccuracyArgsDict']]
        """
        The accuracy health settings for this Deployment.
        """
        actuals_timeliness: NotRequired[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgsDict']]
        """
        The actuals timeliness health settings for this Deployment.
        """
        custom_metrics: NotRequired[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgsDict']]
        """
        The custom metrics health settings for this Deployment.
        """
        data_drift: NotRequired[pulumi.Input['DeploymentHealthSettingsDataDriftArgsDict']]
        """
        The data drift health settings for this Deployment.
        """
        fairness: NotRequired[pulumi.Input['DeploymentHealthSettingsFairnessArgsDict']]
        """
        The fairness health settings for this Deployment.
        """
        predictions_timeliness: NotRequired[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgsDict']]
        """
        The predictions timeliness health settings for this Deployment.
        """
        service: NotRequired[pulumi.Input['DeploymentHealthSettingsServiceArgsDict']]
        """
        The service health settings for this Deployment.
        """
elif False:
    DeploymentHealthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsArgs:
    def __init__(__self__, *,
                 accuracy: Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']] = None,
                 actuals_timeliness: Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']] = None,
                 custom_metrics: Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']] = None,
                 data_drift: Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']] = None,
                 fairness: Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']] = None,
                 predictions_timeliness: Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']] = None,
                 service: Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']] = None):
        """
        :param pulumi.Input['DeploymentHealthSettingsAccuracyArgs'] accuracy: The accuracy health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs'] actuals_timeliness: The actuals timeliness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs'] custom_metrics: The custom metrics health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsDataDriftArgs'] data_drift: The data drift health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsFairnessArgs'] fairness: The fairness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs'] predictions_timeliness: The predictions timeliness health settings for this Deployment.
        :param pulumi.Input['DeploymentHealthSettingsServiceArgs'] service: The service health settings for this Deployment.
        """
        if accuracy is not None:
            pulumi.set(__self__, "accuracy", accuracy)
        if actuals_timeliness is not None:
            pulumi.set(__self__, "actuals_timeliness", actuals_timeliness)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if data_drift is not None:
            pulumi.set(__self__, "data_drift", data_drift)
        if fairness is not None:
            pulumi.set(__self__, "fairness", fairness)
        if predictions_timeliness is not None:
            pulumi.set(__self__, "predictions_timeliness", predictions_timeliness)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def accuracy(self) -> Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']]:
        """
        The accuracy health settings for this Deployment.
        """
        return pulumi.get(self, "accuracy")

    @accuracy.setter
    def accuracy(self, value: Optional[pulumi.Input['DeploymentHealthSettingsAccuracyArgs']]):
        pulumi.set(self, "accuracy", value)

    @property
    @pulumi.getter(name="actualsTimeliness")
    def actuals_timeliness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']]:
        """
        The actuals timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "actuals_timeliness")

    @actuals_timeliness.setter
    def actuals_timeliness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsActualsTimelinessArgs']]):
        pulumi.set(self, "actuals_timeliness", value)

    @property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']]:
        """
        The custom metrics health settings for this Deployment.
        """
        return pulumi.get(self, "custom_metrics")

    @custom_metrics.setter
    def custom_metrics(self, value: Optional[pulumi.Input['DeploymentHealthSettingsCustomMetricsArgs']]):
        pulumi.set(self, "custom_metrics", value)

    @property
    @pulumi.getter(name="dataDrift")
    def data_drift(self) -> Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']]:
        """
        The data drift health settings for this Deployment.
        """
        return pulumi.get(self, "data_drift")

    @data_drift.setter
    def data_drift(self, value: Optional[pulumi.Input['DeploymentHealthSettingsDataDriftArgs']]):
        pulumi.set(self, "data_drift", value)

    @property
    @pulumi.getter
    def fairness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']]:
        """
        The fairness health settings for this Deployment.
        """
        return pulumi.get(self, "fairness")

    @fairness.setter
    def fairness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsFairnessArgs']]):
        pulumi.set(self, "fairness", value)

    @property
    @pulumi.getter(name="predictionsTimeliness")
    def predictions_timeliness(self) -> Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']]:
        """
        The predictions timeliness health settings for this Deployment.
        """
        return pulumi.get(self, "predictions_timeliness")

    @predictions_timeliness.setter
    def predictions_timeliness(self, value: Optional[pulumi.Input['DeploymentHealthSettingsPredictionsTimelinessArgs']]):
        pulumi.set(self, "predictions_timeliness", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']]:
        """
        The service health settings for this Deployment.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['DeploymentHealthSettingsServiceArgs']]):
        pulumi.set(self, "service", value)


if not MYPY:
    class DeploymentHealthSettingsAccuracyArgsDict(TypedDict):
        batch_count: NotRequired[pulumi.Input[int]]
        """
        The batch count for the accuracy health settings.
        """
        failing_threshold: NotRequired[pulumi.Input[float]]
        """
        The failing threshold for the accuracy health settings.
        """
        measurement: NotRequired[pulumi.Input[str]]
        """
        The measurement for the accuracy health settings.
        """
        metric: NotRequired[pulumi.Input[str]]
        """
        The metric for the accuracy health settings.
        """
        warning_threshold: NotRequired[pulumi.Input[float]]
        """
        The warning threshold for the accuracy health settings.
        """
elif False:
    DeploymentHealthSettingsAccuracyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsAccuracyArgs:
    def __init__(__self__, *,
                 batch_count: Optional[pulumi.Input[int]] = None,
                 failing_threshold: Optional[pulumi.Input[float]] = None,
                 measurement: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 warning_threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] batch_count: The batch count for the accuracy health settings.
        :param pulumi.Input[float] failing_threshold: The failing threshold for the accuracy health settings.
        :param pulumi.Input[str] measurement: The measurement for the accuracy health settings.
        :param pulumi.Input[str] metric: The metric for the accuracy health settings.
        :param pulumi.Input[float] warning_threshold: The warning threshold for the accuracy health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if failing_threshold is not None:
            pulumi.set(__self__, "failing_threshold", failing_threshold)
        if measurement is not None:
            pulumi.set(__self__, "measurement", measurement)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if warning_threshold is not None:
            pulumi.set(__self__, "warning_threshold", warning_threshold)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        The batch count for the accuracy health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="failingThreshold")
    def failing_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The failing threshold for the accuracy health settings.
        """
        return pulumi.get(self, "failing_threshold")

    @failing_threshold.setter
    def failing_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "failing_threshold", value)

    @property
    @pulumi.getter
    def measurement(self) -> Optional[pulumi.Input[str]]:
        """
        The measurement for the accuracy health settings.
        """
        return pulumi.get(self, "measurement")

    @measurement.setter
    def measurement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measurement", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric for the accuracy health settings.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="warningThreshold")
    def warning_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The warning threshold for the accuracy health settings.
        """
        return pulumi.get(self, "warning_threshold")

    @warning_threshold.setter
    def warning_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "warning_threshold", value)


if not MYPY:
    class DeploymentHealthSettingsActualsTimelinessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If acutals timeliness is enabled for this Deployment.
        """
        expected_frequency: NotRequired[pulumi.Input[str]]
        """
        The expected frequency for the actuals timeliness health settings.
        """
elif False:
    DeploymentHealthSettingsActualsTimelinessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsActualsTimelinessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 expected_frequency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: If acutals timeliness is enabled for this Deployment.
        :param pulumi.Input[str] expected_frequency: The expected frequency for the actuals timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If acutals timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The expected frequency for the actuals timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")

    @expected_frequency.setter
    def expected_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_frequency", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsArgsDict(TypedDict):
        failing_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict']]]]
        """
        The failing conditions for the custom metrics health settings.
        """
        warning_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict']]]]
        """
        The warning conditions for the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsArgs:
    def __init__(__self__, *,
                 failing_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]] = None,
                 warning_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]] failing_conditions: The failing conditions for the custom metrics health settings.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]] warning_conditions: The warning conditions for the custom metrics health settings.
        """
        if failing_conditions is not None:
            pulumi.set(__self__, "failing_conditions", failing_conditions)
        if warning_conditions is not None:
            pulumi.set(__self__, "warning_conditions", warning_conditions)

    @property
    @pulumi.getter(name="failingConditions")
    def failing_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]]:
        """
        The failing conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "failing_conditions")

    @failing_conditions.setter
    def failing_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsFailingConditionArgs']]]]):
        pulumi.set(self, "failing_conditions", value)

    @property
    @pulumi.getter(name="warningConditions")
    def warning_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]]:
        """
        The warning conditions for the custom metrics health settings.
        """
        return pulumi.get(self, "warning_conditions")

    @warning_conditions.setter
    def warning_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentHealthSettingsCustomMetricsWarningConditionArgs']]]]):
        pulumi.set(self, "warning_conditions", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict(TypedDict):
        compare_operator: pulumi.Input[str]
        """
        The compare operator for the failing condition of the custom metrics health settings.
        """
        metric_id: pulumi.Input[str]
        """
        The metric ID for the failing condition of the custom metrics health settings.
        """
        threshold: pulumi.Input[float]
        """
        The threshold for the failing condition of the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsFailingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsFailingConditionArgs:
    def __init__(__self__, *,
                 compare_operator: pulumi.Input[str],
                 metric_id: pulumi.Input[str],
                 threshold: pulumi.Input[float]):
        """
        :param pulumi.Input[str] compare_operator: The compare operator for the failing condition of the custom metrics health settings.
        :param pulumi.Input[str] metric_id: The metric ID for the failing condition of the custom metrics health settings.
        :param pulumi.Input[float] threshold: The threshold for the failing condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> pulumi.Input[str]:
        """
        The compare operator for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @compare_operator.setter
    def compare_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "compare_operator", value)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> pulumi.Input[str]:
        """
        The metric ID for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @metric_id.setter
    def metric_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_id", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold for the failing condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict(TypedDict):
        compare_operator: pulumi.Input[str]
        """
        The compare operator for the warning condition of the custom metrics health settings.
        """
        metric_id: pulumi.Input[str]
        """
        The metric ID for the warning condition of the custom metrics health settings.
        """
        threshold: pulumi.Input[float]
        """
        The threshold for the warning condition of the custom metrics health settings.
        """
elif False:
    DeploymentHealthSettingsCustomMetricsWarningConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsCustomMetricsWarningConditionArgs:
    def __init__(__self__, *,
                 compare_operator: pulumi.Input[str],
                 metric_id: pulumi.Input[str],
                 threshold: pulumi.Input[float]):
        """
        :param pulumi.Input[str] compare_operator: The compare operator for the warning condition of the custom metrics health settings.
        :param pulumi.Input[str] metric_id: The metric ID for the warning condition of the custom metrics health settings.
        :param pulumi.Input[float] threshold: The threshold for the warning condition of the custom metrics health settings.
        """
        pulumi.set(__self__, "compare_operator", compare_operator)
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="compareOperator")
    def compare_operator(self) -> pulumi.Input[str]:
        """
        The compare operator for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "compare_operator")

    @compare_operator.setter
    def compare_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "compare_operator", value)

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> pulumi.Input[str]:
        """
        The metric ID for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "metric_id")

    @metric_id.setter
    def metric_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_id", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold for the warning condition of the custom metrics health settings.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class DeploymentHealthSettingsDataDriftArgsDict(TypedDict):
        batch_count: NotRequired[pulumi.Input[int]]
        """
        The batch count for the data drift health settings.
        """
        drift_threshold: NotRequired[pulumi.Input[float]]
        """
        The drift threshold for the data drift health settings.
        """
        exclude_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The exclude features for the data drift health settings.
        """
        high_importance_failing_count: NotRequired[pulumi.Input[int]]
        """
        The high importance failing count for the data drift health settings.
        """
        high_importance_warning_count: NotRequired[pulumi.Input[int]]
        """
        The high importance warning count for the data drift health settings.
        """
        importance_threshold: NotRequired[pulumi.Input[float]]
        """
        The importance threshold for the data drift health settings.
        """
        low_importance_failing_count: NotRequired[pulumi.Input[int]]
        """
        The low importance failing count for the data drift health settings.
        """
        low_importance_warning_count: NotRequired[pulumi.Input[int]]
        """
        The low importance warning count for the data drift health settings.
        """
        starred_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The starred features for the data drift health settings.
        """
        time_interval: NotRequired[pulumi.Input[str]]
        """
        The time interval for the data drift health settings.
        """
elif False:
    DeploymentHealthSettingsDataDriftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsDataDriftArgs:
    def __init__(__self__, *,
                 batch_count: Optional[pulumi.Input[int]] = None,
                 drift_threshold: Optional[pulumi.Input[float]] = None,
                 exclude_features: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 high_importance_failing_count: Optional[pulumi.Input[int]] = None,
                 high_importance_warning_count: Optional[pulumi.Input[int]] = None,
                 importance_threshold: Optional[pulumi.Input[float]] = None,
                 low_importance_failing_count: Optional[pulumi.Input[int]] = None,
                 low_importance_warning_count: Optional[pulumi.Input[int]] = None,
                 starred_features: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] batch_count: The batch count for the data drift health settings.
        :param pulumi.Input[float] drift_threshold: The drift threshold for the data drift health settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_features: The exclude features for the data drift health settings.
        :param pulumi.Input[int] high_importance_failing_count: The high importance failing count for the data drift health settings.
        :param pulumi.Input[int] high_importance_warning_count: The high importance warning count for the data drift health settings.
        :param pulumi.Input[float] importance_threshold: The importance threshold for the data drift health settings.
        :param pulumi.Input[int] low_importance_failing_count: The low importance failing count for the data drift health settings.
        :param pulumi.Input[int] low_importance_warning_count: The low importance warning count for the data drift health settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] starred_features: The starred features for the data drift health settings.
        :param pulumi.Input[str] time_interval: The time interval for the data drift health settings.
        """
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if drift_threshold is not None:
            pulumi.set(__self__, "drift_threshold", drift_threshold)
        if exclude_features is not None:
            pulumi.set(__self__, "exclude_features", exclude_features)
        if high_importance_failing_count is not None:
            pulumi.set(__self__, "high_importance_failing_count", high_importance_failing_count)
        if high_importance_warning_count is not None:
            pulumi.set(__self__, "high_importance_warning_count", high_importance_warning_count)
        if importance_threshold is not None:
            pulumi.set(__self__, "importance_threshold", importance_threshold)
        if low_importance_failing_count is not None:
            pulumi.set(__self__, "low_importance_failing_count", low_importance_failing_count)
        if low_importance_warning_count is not None:
            pulumi.set(__self__, "low_importance_warning_count", low_importance_warning_count)
        if starred_features is not None:
            pulumi.set(__self__, "starred_features", starred_features)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        The batch count for the data drift health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="driftThreshold")
    def drift_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The drift threshold for the data drift health settings.
        """
        return pulumi.get(self, "drift_threshold")

    @drift_threshold.setter
    def drift_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "drift_threshold", value)

    @property
    @pulumi.getter(name="excludeFeatures")
    def exclude_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The exclude features for the data drift health settings.
        """
        return pulumi.get(self, "exclude_features")

    @exclude_features.setter
    def exclude_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_features", value)

    @property
    @pulumi.getter(name="highImportanceFailingCount")
    def high_importance_failing_count(self) -> Optional[pulumi.Input[int]]:
        """
        The high importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_failing_count")

    @high_importance_failing_count.setter
    def high_importance_failing_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_importance_failing_count", value)

    @property
    @pulumi.getter(name="highImportanceWarningCount")
    def high_importance_warning_count(self) -> Optional[pulumi.Input[int]]:
        """
        The high importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "high_importance_warning_count")

    @high_importance_warning_count.setter
    def high_importance_warning_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_importance_warning_count", value)

    @property
    @pulumi.getter(name="importanceThreshold")
    def importance_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The importance threshold for the data drift health settings.
        """
        return pulumi.get(self, "importance_threshold")

    @importance_threshold.setter
    def importance_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "importance_threshold", value)

    @property
    @pulumi.getter(name="lowImportanceFailingCount")
    def low_importance_failing_count(self) -> Optional[pulumi.Input[int]]:
        """
        The low importance failing count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_failing_count")

    @low_importance_failing_count.setter
    def low_importance_failing_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "low_importance_failing_count", value)

    @property
    @pulumi.getter(name="lowImportanceWarningCount")
    def low_importance_warning_count(self) -> Optional[pulumi.Input[int]]:
        """
        The low importance warning count for the data drift health settings.
        """
        return pulumi.get(self, "low_importance_warning_count")

    @low_importance_warning_count.setter
    def low_importance_warning_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "low_importance_warning_count", value)

    @property
    @pulumi.getter(name="starredFeatures")
    def starred_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The starred features for the data drift health settings.
        """
        return pulumi.get(self, "starred_features")

    @starred_features.setter
    def starred_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "starred_features", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time interval for the data drift health settings.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_interval", value)


if not MYPY:
    class DeploymentHealthSettingsFairnessArgsDict(TypedDict):
        protected_class_failing_count: NotRequired[pulumi.Input[int]]
        """
        The protected class failing count for the fairness health settings.
        """
        protected_class_warning_count: NotRequired[pulumi.Input[int]]
        """
        The protected class warning count for the fairness health settings.
        """
elif False:
    DeploymentHealthSettingsFairnessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsFairnessArgs:
    def __init__(__self__, *,
                 protected_class_failing_count: Optional[pulumi.Input[int]] = None,
                 protected_class_warning_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] protected_class_failing_count: The protected class failing count for the fairness health settings.
        :param pulumi.Input[int] protected_class_warning_count: The protected class warning count for the fairness health settings.
        """
        if protected_class_failing_count is not None:
            pulumi.set(__self__, "protected_class_failing_count", protected_class_failing_count)
        if protected_class_warning_count is not None:
            pulumi.set(__self__, "protected_class_warning_count", protected_class_warning_count)

    @property
    @pulumi.getter(name="protectedClassFailingCount")
    def protected_class_failing_count(self) -> Optional[pulumi.Input[int]]:
        """
        The protected class failing count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_failing_count")

    @protected_class_failing_count.setter
    def protected_class_failing_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "protected_class_failing_count", value)

    @property
    @pulumi.getter(name="protectedClassWarningCount")
    def protected_class_warning_count(self) -> Optional[pulumi.Input[int]]:
        """
        The protected class warning count for the fairness health settings.
        """
        return pulumi.get(self, "protected_class_warning_count")

    @protected_class_warning_count.setter
    def protected_class_warning_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "protected_class_warning_count", value)


if not MYPY:
    class DeploymentHealthSettingsPredictionsTimelinessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If predictions timeliness is enabled for this Deployment.
        """
        expected_frequency: NotRequired[pulumi.Input[str]]
        """
        The expected frequency for the predictions timeliness health settings.
        """
elif False:
    DeploymentHealthSettingsPredictionsTimelinessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsPredictionsTimelinessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 expected_frequency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: If predictions timeliness is enabled for this Deployment.
        :param pulumi.Input[str] expected_frequency: The expected frequency for the predictions timeliness health settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if expected_frequency is not None:
            pulumi.set(__self__, "expected_frequency", expected_frequency)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If predictions timeliness is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="expectedFrequency")
    def expected_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The expected frequency for the predictions timeliness health settings.
        """
        return pulumi.get(self, "expected_frequency")

    @expected_frequency.setter
    def expected_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_frequency", value)


if not MYPY:
    class DeploymentHealthSettingsServiceArgsDict(TypedDict):
        batch_count: pulumi.Input[int]
        """
        The batch count for the service health settings.
        """
elif False:
    DeploymentHealthSettingsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentHealthSettingsServiceArgs:
    def __init__(__self__, *,
                 batch_count: pulumi.Input[int]):
        """
        :param pulumi.Input[int] batch_count: The batch count for the service health settings.
        """
        pulumi.set(__self__, "batch_count", batch_count)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> pulumi.Input[int]:
        """
        The batch count for the service health settings.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_count", value)


if not MYPY:
    class DeploymentPredictionIntervalsSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether prediction intervals are enabled for this deployment.
        """
        percentiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of enabled prediction intervals sizes for this deployment.
        """
elif False:
    DeploymentPredictionIntervalsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionIntervalsSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 percentiles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether prediction intervals are enabled for this deployment.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] percentiles: List of enabled prediction intervals sizes for this deployment.
        """
        pulumi.set(__self__, "enabled", enabled)
        if percentiles is not None:
            pulumi.set(__self__, "percentiles", percentiles)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether prediction intervals are enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of enabled prediction intervals sizes for this deployment.
        """
        return pulumi.get(self, "percentiles")

    @percentiles.setter
    def percentiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "percentiles", value)


if not MYPY:
    class DeploymentPredictionWarningSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If target prediction warning is enabled for this Deployment.
        """
        custom_boundaries: NotRequired[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgsDict']]
        """
        The custom boundaries for prediction warnings.
        """
elif False:
    DeploymentPredictionWarningSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionWarningSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 custom_boundaries: Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']] = None):
        """
        :param pulumi.Input[bool] enabled: If target prediction warning is enabled for this Deployment.
        :param pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs'] custom_boundaries: The custom boundaries for prediction warnings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_boundaries is not None:
            pulumi.set(__self__, "custom_boundaries", custom_boundaries)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If target prediction warning is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="customBoundaries")
    def custom_boundaries(self) -> Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']]:
        """
        The custom boundaries for prediction warnings.
        """
        return pulumi.get(self, "custom_boundaries")

    @custom_boundaries.setter
    def custom_boundaries(self, value: Optional[pulumi.Input['DeploymentPredictionWarningSettingsCustomBoundariesArgs']]):
        pulumi.set(self, "custom_boundaries", value)


if not MYPY:
    class DeploymentPredictionWarningSettingsCustomBoundariesArgsDict(TypedDict):
        lower_boundary: NotRequired[pulumi.Input[float]]
        """
        All predictions less than provided value will be considered anomalous.
        """
        upper_boundary: NotRequired[pulumi.Input[float]]
        """
        All predictions greater than provided value will be considered anomalous.
        """
elif False:
    DeploymentPredictionWarningSettingsCustomBoundariesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionWarningSettingsCustomBoundariesArgs:
    def __init__(__self__, *,
                 lower_boundary: Optional[pulumi.Input[float]] = None,
                 upper_boundary: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] lower_boundary: All predictions less than provided value will be considered anomalous.
        :param pulumi.Input[float] upper_boundary: All predictions greater than provided value will be considered anomalous.
        """
        if lower_boundary is not None:
            pulumi.set(__self__, "lower_boundary", lower_boundary)
        if upper_boundary is not None:
            pulumi.set(__self__, "upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[pulumi.Input[float]]:
        """
        All predictions less than provided value will be considered anomalous.
        """
        return pulumi.get(self, "lower_boundary")

    @lower_boundary.setter
    def lower_boundary(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lower_boundary", value)

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[pulumi.Input[float]]:
        """
        All predictions greater than provided value will be considered anomalous.
        """
        return pulumi.get(self, "upper_boundary")

    @upper_boundary.setter
    def upper_boundary(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upper_boundary", value)


if not MYPY:
    class DeploymentPredictionsByForecastDateSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is True if predictions by forecast date is enabled for this deployment.
        """
        column_name: NotRequired[pulumi.Input[str]]
        """
        The column name in prediction datasets to be used as forecast date.
        """
        datetime_format: NotRequired[pulumi.Input[str]]
        """
        The datetime format of the forecast date column in prediction datasets.
        """
elif False:
    DeploymentPredictionsByForecastDateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsByForecastDateSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 column_name: Optional[pulumi.Input[str]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Is True if predictions by forecast date is enabled for this deployment.
        :param pulumi.Input[str] column_name: The column name in prediction datasets to be used as forecast date.
        :param pulumi.Input[str] datetime_format: The datetime format of the forecast date column in prediction datasets.
        """
        pulumi.set(__self__, "enabled", enabled)
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if datetime_format is not None:
            pulumi.set(__self__, "datetime_format", datetime_format)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is True if predictions by forecast date is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The column name in prediction datasets to be used as forecast date.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        """
        The datetime format of the forecast date column in prediction datasets.
        """
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)


if not MYPY:
    class DeploymentPredictionsDataCollectionSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If predictions data collections is enabled for this Deployment.
        """
elif False:
    DeploymentPredictionsDataCollectionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsDataCollectionSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: If predictions data collections is enabled for this Deployment.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If predictions data collections is enabled for this Deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeploymentPredictionsSettingsArgsDict(TypedDict):
        max_computes: pulumi.Input[int]
        """
        The maximum number of computes to use for predictions.
        """
        min_computes: pulumi.Input[int]
        """
        The minimum number of computes to use for predictions.
        """
        real_time: pulumi.Input[bool]
        """
        Whether to use real-time predictions.
        """
elif False:
    DeploymentPredictionsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPredictionsSettingsArgs:
    def __init__(__self__, *,
                 max_computes: pulumi.Input[int],
                 min_computes: pulumi.Input[int],
                 real_time: pulumi.Input[bool]):
        """
        :param pulumi.Input[int] max_computes: The maximum number of computes to use for predictions.
        :param pulumi.Input[int] min_computes: The minimum number of computes to use for predictions.
        :param pulumi.Input[bool] real_time: Whether to use real-time predictions.
        """
        pulumi.set(__self__, "max_computes", max_computes)
        pulumi.set(__self__, "min_computes", min_computes)
        pulumi.set(__self__, "real_time", real_time)

    @property
    @pulumi.getter(name="maxComputes")
    def max_computes(self) -> pulumi.Input[int]:
        """
        The maximum number of computes to use for predictions.
        """
        return pulumi.get(self, "max_computes")

    @max_computes.setter
    def max_computes(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_computes", value)

    @property
    @pulumi.getter(name="minComputes")
    def min_computes(self) -> pulumi.Input[int]:
        """
        The minimum number of computes to use for predictions.
        """
        return pulumi.get(self, "min_computes")

    @min_computes.setter
    def min_computes(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_computes", value)

    @property
    @pulumi.getter(name="realTime")
    def real_time(self) -> pulumi.Input[bool]:
        """
        Whether to use real-time predictions.
        """
        return pulumi.get(self, "real_time")

    @real_time.setter
    def real_time(self, value: pulumi.Input[bool]):
        pulumi.set(self, "real_time", value)


if not MYPY:
    class DeploymentSegmentAnalysisSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Set to 'True' if segment analysis is enabled for this deployment.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of strings that gives the segment attributes selected for tracking.
        """
elif False:
    DeploymentSegmentAnalysisSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSegmentAnalysisSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Set to 'True' if segment analysis is enabled for this deployment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attributes: A list of strings that gives the segment attributes selected for tracking.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Set to 'True' if segment analysis is enabled for this deployment.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings that gives the segment attributes selected for tracking.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class LlmBlueprintLlmSettingsArgsDict(TypedDict):
        max_completion_length: NotRequired[pulumi.Input[int]]
        """
        The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        """
        system_prompt: NotRequired[pulumi.Input[str]]
        """
        Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        temperature: NotRequired[pulumi.Input[float]]
        """
        Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        """
        top_p: NotRequired[pulumi.Input[float]]
        """
        Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
elif False:
    LlmBlueprintLlmSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LlmBlueprintLlmSettingsArgs:
    def __init__(__self__, *,
                 max_completion_length: Optional[pulumi.Input[int]] = None,
                 system_prompt: Optional[pulumi.Input[str]] = None,
                 temperature: Optional[pulumi.Input[float]] = None,
                 top_p: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] max_completion_length: The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        :param pulumi.Input[str] system_prompt: Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        :param pulumi.Input[float] temperature: Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        :param pulumi.Input[float] top_p: Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        if max_completion_length is not None:
            pulumi.set(__self__, "max_completion_length", max_completion_length)
        if system_prompt is not None:
            pulumi.set(__self__, "system_prompt", system_prompt)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxCompletionLength")
    def max_completion_length(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of tokens allowed in the completion. The combined count of this value and prompt tokens must be below the model's maximum context size, where prompt token count is comprised of system prompt, user prompt, recent chat history, and vector database citations.
        """
        return pulumi.get(self, "max_completion_length")

    @max_completion_length.setter
    def max_completion_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_completion_length", value)

    @property
    @pulumi.getter(name="systemPrompt")
    def system_prompt(self) -> Optional[pulumi.Input[str]]:
        """
        Guides the style of the LLM response. It is a 'universal' prompt, prepended to all individual prompts.
        """
        return pulumi.get(self, "system_prompt")

    @system_prompt.setter
    def system_prompt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "system_prompt", value)

    @property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[float]]:
        """
        Controls the randomness of model output, where higher values return more diverse output and lower values return more deterministic results.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[float]]:
        """
        Threshold that controls the selection of words included in the response, based on a cumulative probability cutoff for token selection. Higher numbers return more diverse options for outputs.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class LlmBlueprintVectorDatabaseSettingsArgsDict(TypedDict):
        max_documents_retrieved_per_prompt: NotRequired[pulumi.Input[int]]
        """
        The maximum number of documents to retrieve from the Vector Database.
        """
        max_tokens: NotRequired[pulumi.Input[int]]
        """
        The maximum number of tokens to retrieve from the Vector Database.
        """
elif False:
    LlmBlueprintVectorDatabaseSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LlmBlueprintVectorDatabaseSettingsArgs:
    def __init__(__self__, *,
                 max_documents_retrieved_per_prompt: Optional[pulumi.Input[int]] = None,
                 max_tokens: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_documents_retrieved_per_prompt: The maximum number of documents to retrieve from the Vector Database.
        :param pulumi.Input[int] max_tokens: The maximum number of tokens to retrieve from the Vector Database.
        """
        if max_documents_retrieved_per_prompt is not None:
            pulumi.set(__self__, "max_documents_retrieved_per_prompt", max_documents_retrieved_per_prompt)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxDocumentsRetrievedPerPrompt")
    def max_documents_retrieved_per_prompt(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of documents to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_documents_retrieved_per_prompt")

    @max_documents_retrieved_per_prompt.setter
    def max_documents_retrieved_per_prompt(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_documents_retrieved_per_prompt", value)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of tokens to retrieve from the Vector Database.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class VectorDatabaseChunkingParametersArgsDict(TypedDict):
        chunk_overlap_percentage: NotRequired[pulumi.Input[int]]
        """
        The percentage of overlap between chunks.
        """
        chunk_size: NotRequired[pulumi.Input[int]]
        """
        The size of the chunks.
        """
        chunking_method: NotRequired[pulumi.Input[str]]
        """
        The method used to chunk the data.
        """
        embedding_model: NotRequired[pulumi.Input[str]]
        """
        The id of the Embedding Model.
        """
        is_separator_regex: NotRequired[pulumi.Input[bool]]
        """
        Whether the separator is a regex.
        """
        separators: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The separators used to split the data.
        """
elif False:
    VectorDatabaseChunkingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorDatabaseChunkingParametersArgs:
    def __init__(__self__, *,
                 chunk_overlap_percentage: Optional[pulumi.Input[int]] = None,
                 chunk_size: Optional[pulumi.Input[int]] = None,
                 chunking_method: Optional[pulumi.Input[str]] = None,
                 embedding_model: Optional[pulumi.Input[str]] = None,
                 is_separator_regex: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] chunk_overlap_percentage: The percentage of overlap between chunks.
        :param pulumi.Input[int] chunk_size: The size of the chunks.
        :param pulumi.Input[str] chunking_method: The method used to chunk the data.
        :param pulumi.Input[str] embedding_model: The id of the Embedding Model.
        :param pulumi.Input[bool] is_separator_regex: Whether the separator is a regex.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: The separators used to split the data.
        """
        if chunk_overlap_percentage is not None:
            pulumi.set(__self__, "chunk_overlap_percentage", chunk_overlap_percentage)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if chunking_method is not None:
            pulumi.set(__self__, "chunking_method", chunking_method)
        if embedding_model is not None:
            pulumi.set(__self__, "embedding_model", embedding_model)
        if is_separator_regex is not None:
            pulumi.set(__self__, "is_separator_regex", is_separator_regex)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="chunkOverlapPercentage")
    def chunk_overlap_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of overlap between chunks.
        """
        return pulumi.get(self, "chunk_overlap_percentage")

    @chunk_overlap_percentage.setter
    def chunk_overlap_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap_percentage", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the chunks.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkingMethod")
    def chunking_method(self) -> Optional[pulumi.Input[str]]:
        """
        The method used to chunk the data.
        """
        return pulumi.get(self, "chunking_method")

    @chunking_method.setter
    def chunking_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunking_method", value)

    @property
    @pulumi.getter(name="embeddingModel")
    def embedding_model(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the Embedding Model.
        """
        return pulumi.get(self, "embedding_model")

    @embedding_model.setter
    def embedding_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "embedding_model", value)

    @property
    @pulumi.getter(name="isSeparatorRegex")
    def is_separator_regex(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the separator is a regex.
        """
        return pulumi.get(self, "is_separator_regex")

    @is_separator_regex.setter
    def is_separator_regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_separator_regex", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The separators used to split the data.
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


